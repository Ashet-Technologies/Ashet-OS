const std = @import("std");
const disk_image_step = @import("disk-image-step");

const AssetBundleStep = @This();

step: std.Build.Step,
builder: *std.build.Builder,
files: std.StringHashMap(std.Build.FileSource),
output_file: std.Build.GeneratedFile,
rootfs: ?*disk_image_step.FileSystemBuilder,

pub fn create(builder: *std.Build, rootfs: ?*disk_image_step.FileSystemBuilder) *AssetBundleStep {
    const bundle = builder.allocator.create(AssetBundleStep) catch @panic("oom");
    errdefer builder.allocator.destroy(bundle);

    bundle.* = AssetBundleStep{
        .step = std.Build.Step.init(.{
            .id = .custom,
            .name = "bundle assets",
            .owner = builder,
            .makeFn = make,
            .first_ret_addr = null,
            .max_rss = 0,
        }),
        .builder = builder,
        .files = std.StringHashMap(std.Build.FileSource).init(builder.allocator),
        .output_file = .{ .step = &bundle.step },
        .rootfs = rootfs,
    };

    return bundle;
}

pub fn add(bundle: *AssetBundleStep, path: []const u8, item: std.Build.FileSource) void {
    bundle.files.putNoClobber(
        bundle.builder.dupe(path),
        item,
    ) catch @panic("oom");
    item.addStepDependencies(&bundle.step);

    if (bundle.rootfs) |rootfs|
        rootfs.addFile(item, path);

    // const install_step = bundle.builder.addInstallFile(item, path);
    // install_step.dir = rootfs_dir;
    // bundle.builder.getInstallStep().dependOn(&install_step.step);
}

pub fn getOutput(bundle: *AssetBundleStep) std.Build.FileSource {
    return std.Build.FileSource{
        .generated = &bundle.output_file,
    };
}

fn make(step: *std.build.Step, node: *std.Progress.Node) !void {
    const bundle = @fieldParentPtr(AssetBundleStep, "step", step);

    var write_step = std.Build.WriteFileStep.create(bundle.builder);

    var embed_file = std.ArrayList(u8).init(bundle.builder.allocator);
    defer embed_file.deinit();

    const writer = embed_file.writer();

    try writer.writeAll(
        \\//! AUTOGENERATED CODE
        \\
    );

    {
        var it = bundle.files.iterator();
        while (it.next()) |kv| {
            _ = write_step.addCopyFile(
                kv.value_ptr.*,
                bundle.builder.fmt("blobs/{s}", .{kv.key_ptr.*}),
            );
            try writer.print("pub const {} = @embedFile(\"blobs/{}\");\n", .{
                std.zig.fmtId(kv.key_ptr.*),
                std.zig.fmtEscapes(kv.key_ptr.*),
            });
        }
    }

    const bundle_file_source = write_step.add("bundle.zig", try embed_file.toOwnedSlice());

    try write_step.step.makeFn(&write_step.step, node);

    bundle.output_file.path = bundle_file_source.getPath(bundle.builder);
}
