#
# WARNING:
#     THIS FILE CONTAINS A DSL THAT LOOKS LIKE ZIG BUT NEEDS TO BE
#     PROCESSED BY `tools/abi-mapper.py` IN ORDER TO BE COMPILABLE!
#

///////////////////////////////////////////////////////////
# Syscalls & Asynchronous/Overlapped Operations

/// All syscalls related to generic resource management.
const resources = struct {
    /// Returns the type of the system resource.
    extern fn get_type(SystemResource) error{InvalidHandle}!SystemResource.Type;

    /// Returns the current owner of this resource.
    extern fn get_owners(SystemResource, owners: ?[]Process) usize;

    /// Adds the process to the owners of this resource, so the process
    /// can safely access it without fear of having a use-after-free.
    extern fn send_to_process(SystemResource, Process) error{ SystemResources, InvalidHandle, DeadProcess }!void;

    /// Drops the ownership of the resource for the current process.
    /// If no owner remains, the resource will be destroyed and it's
    /// memory will be released.
    /// The handle must be assumed invalid for this process after
    /// this function returns.
    extern fn release(SystemResource) void;

    /// Immediatly destroys the resource and releases its memory.
    ///
    /// NOTE: This will *always* destroy the resource, even if it's
    ///       also owned by another process.
    extern fn destroy(SystemResource) void;
};

const overlapped = struct {
    /// Handle to an asynchronously running (system) call.
    struct ARC 
    {
        /// The type of operation that is performed.
        field type: Type;
        /// A user-specified pointer-sized field which 
        field tag: usize; 
    }

    /// Starts new asynchronous operations.
    ///
    /// NOTE: Until the operation has successfully completed or was
    ///       cancelled, the ARC structure must be considered owned
    ///       by the kernel and must not be changed from userspace.
    ///       It can also change its contents spuriously until the
    ///       operation is returned to userland.
    ///
    extern fn schedule(async_call: *ARC) error{ SystemResources, AlreadyScheduled }!void;

    /// Awaits one or more scheduled asynchronous operations and returns the
    /// number of `completed` elements.
    ///
    /// The kernel will fill out `completed` up to the returned number of elements.
    /// All other values are undefined.
    ///
    /// NOTE: See also: `await_completion_of`
    ///
    /// NOTE: For blocking operations, this function will suspend the current
    ///       thread until the request has been completed.
    extern fn await_completion(completed: []*ARC, options: Await_Options) error{Unscheduled}!usize;

    /// Awaits one or more explictic asynchronous operations and returns the
    /// number of `events` elements.
    ///
    /// The kernel will only await elements provided in `events` and all of those events must
    /// not be awaited by another `await_completion_of`.
    ///
    /// When the function returns, `events` will have all completed events unchanged, and all
    /// unfinished events set to `null`. This way, a simple check via index can be done instead of
    /// the need for iteration of `events` to find what was finished.
    ///
    /// NOTE: This syscall will always return as soon as a single event has finished.
    ///
    /// NOTE: It is invalid to await the same operation with two concurrent calls to `await_completion_of`.
    ///
    /// NOTE: Elements awaited with this function will be guaranteed to not be returned by
    ///       another concurrent call to `await_completion`.
    ///
    /// NOTE: See also: `await_completion`
    ///
    /// NOTE: For blocking operations, this function will suspend the current
    ///       thread until the request has been completed.
    extern fn await_completion_of(events: []?*ARC) error{ Unscheduled, InvalidOperation }!usize;

    /// Cancels an asynchronous call.
    ///
    /// NOTE: If the operation has already completed, an error will be returned saying so.
    ///
    /// NOTE: The cancelled operation will not be returned by `await` anymore.
    extern fn cancel(aop: *ARC) error{
        Unscheduled,
        Completed,
    }!void;
};

/// Syscalls related to processes
const process = struct {
    /// Returns a pointer to the file name of the process.
    extern fn get_file_name(?Process) [*:0]const u8;

    /// Returns the base address of the process.
    extern fn get_base_address(?Process) usize;

    /// Returns the arguments that were passed to this process in `Spawn`.
    extern fn get_arguments(?Process, argv: ?[]SpawnProcessArg) usize;

    /// Terminates the current process with the given exit code
    extern fn terminate(exit_code: ExitCode) noreturn;

    /// Terminates a foreign process.
    /// If the current process is passed, this function will not return
    extern fn kill(Process) void;

    /// Spawns a new process
    extern "async" fn Spawn(
        /// Relative banse directory for `path`.
        dir: Directory,
        /// File name of the executable relative to `dir`.
        path: []const u8,
        /// The arguments passed to the process.
        /// If a `SystemResource` is passed, it will receive the created process as a owning process.
        /// It is safe to release the resource in this process as soon as this operation returns.
        argv: []const SpawnProcessArg,
    ) error{
        SystemResources,
        FileNotFound,
        InvalidPath,
        BadExecutable,
        InvalidHandle,
        DiskError,
    }!struct {
        /// Handle to the spawned process.
        process: Process,
    };

    const thread = struct {
        /// Returns control to the scheduler. Returns when the scheduler
        /// schedules the process again.
        extern fn yield() void;

        /// Terminates the current thread.
        extern fn exit(exit_code: ExitCode) noreturn;

        /// Waits for the thread to exit and returns its return code.
        extern fn join(Thread) ExitCode;

        /// Spawns a new thread with `function` passing `arg` to it.
        /// If `stack_size` is not 0, will create a stack with the given size.
        extern fn spawn(function: ThreadFunction, arg: ?*anyopaque, stack_size: usize) ?Thread;

        /// Kills the given thread with `exit_code`.
        extern fn kill(Thread, exit_code: ExitCode) void;
    };

    const debug = struct {
        /// Writes to the system debug log.
        extern fn write_log(log_level: LogLevel, message: []const u8) void;

        /// Stops the process and allows debugging.
        extern fn breakpoint() void;
    };

    const memory = struct {
        /// Allocates memory
        extern fn allocate(size: usize, ptr_align: u8) ?[*]u8;

        /// Returns memory to the systme.
        extern fn release(mem: []u8, ptr_align: u8) void;
    };

    const monitor = struct {
        /// Queries all owned resources by a process.
        extern fn enumerate_processes(processes: ?[]Process) usize;

        /// Queries all owned resources by a process.
        extern fn query_owned_resources(owner: Process, reslist: ?[]SystemResource) usize;

        /// Returns the total number of bytes the process takes up in RAM.
        extern fn query_total_memory_usage(proc: Process) usize;

        /// Returns the number of dynamically allocated bytes for this process.
        extern fn query_dynamic_memory_usage(proc: Process) usize;

        /// Returns the number of total memory objects this process has right now.
        extern fn query_active_allocation_count(proc: Process) usize;
    };
};

const clock = struct {
    /// Returns the time in nanoseconds since system startup.
    /// This clock is monotonically increasing.
    extern fn monotonic() Absolute;

    /// Sleeps until `clock.monotonic()` returns at least `timeout`.
    extern "async" fn Timer(
        /// Monotonic timestamp in nanoseconds until the operation completes.
        timeout: Absolute,
    ) error{}!void;
};

const datetime = struct {
    /// Get a calendar timestamp relative to UTC 1970-01-01.
    /// Precision of timing depends on the hardware.
    /// The return value is signed because it is possible to have a date that is
    /// before the epoch.
    extern fn now() DateTime;

    /// Sleeps until `datetime.now()` returns a point in  time that comes after `when`.
    extern "async" fn Alarm(
        /// Earliest possible date time of when the alarm triggers.
        when: DateTime,
    ) error{}!void;
};

const video = struct {
    /// Returns a list of all video outputs.
    ///
    /// If `ids` is `null`, the total number of available outputs is returned,
    /// otherwise, up to `ids.len` elements are written into the provided array
    /// and the number of written elements is returned.
    extern fn enumerate(ids: ?[]VideoOutputID) usize;

    /// Acquire exclusive access to a video output.
    extern fn acquire(VideoOutputID) error{
        SystemResources,
        NotFound,
        NotAvailable,
    }!VideoOutput;

    /// Returns the current resolution
    extern fn get_resolution(VideoOutput) error{InvalidHandle}!Size;

    /// Returns a pointer to linear video memory, row-major.
    /// Pixels rows will have a stride of the current video buffer width.
    /// The first pixel in the memory is the top-left pixel.
    extern fn get_video_memory(VideoOutput) error{InvalidHandle}!VideoMemory;

    /// Completes when the video output has fully scanned out an image and is now performing the v-blanking.
    ///
    /// This allows frame-synchronized presentation of video data.
    extern "async" fn WaitForVBlank(
        output: VideoOutput,
    ) error{InvalidHandle}!void;

    # /// Returns a pointer to the current palette. Changing this palette
    # /// will directly change the associated colors on the screen.
    # /// If `null` is returned, no direct access to the video palette is possible.
    #  fn get_palette_memory(*VideoOutput) ?*[palette_size]Color;

    # /// Returns the maximum possible screen resolution.
    #  fn get_max_resolution(*VideoOutput) Size;

    # /// Sets the screen resolution. Legal values are between 1×1 and the platform specific
    # /// maximum resolution returned by `video.getMaxResolution()`.
    # /// Everything out of bounds will be clamped into that range.
    #  fn change_resolution(*VideoOutput, u16, u16) void;
};

const random = struct {
    /// Fills the provided pointer with random bytes from the entropy pool.
    ///
    /// If the entropy pool runs out of entropy bits, this call does not block
    /// and draw bytes from the pool.
    extern fn get_soft_random(data: []u8) void;

    /// Fills the provided buffer with given length amount of random bytes.
    ///
    /// This call blocks until the entropy pool has enough entropy to fill
    /// an entire hash to draw from.
    extern "async" fn GetStrictRandom(data: []u8) error{}!void;
};

const input = struct {
    /// Waits for an input event and completes when any input was done.
    extern "async" fn GetEvent() error{
        NonExclusiveAccess,
        InProgress,
    }!struct {
        event: InputEvent,
    };
};

const network = struct {
    # getStatus: FnPtr(fn () NetworkStatus),
    # ping: FnPtr(fn ([*]Ping, usize) void),
    # TODO: Implement NIC-specific queries (mac, ips, names, ...)

    const dns = struct {
        # resolves the dns entry `host` for the given `service`.
        # - `host` is a legal dns entry
        # - `port` is either a port number
        # - `buffer` and `limit` define a structure where all resolved IPs can be stored.
        # Function returns the number of host entries found or 0 if the host name could not be resolved.
        #  fn @"resolve" (host: [*:0]const u8, port: u16, buffer: [*]EndPoint, limit: usize) usize;

    };

    pub const udp = struct {
        /// Creates a new TCP socket.
        extern fn create_socket() error{SystemResources}!UdpSocket;

        extern "async" fn Bind(socket: UdpSocket, bind_point: EndPoint) error{
            InvalidHandle,
            SystemResources,
            AddressInUse,
            IllegalValue,
        }!struct {
            bind_point: EndPoint,
        };

        extern "async" fn Connect(
            socket: UdpSocket,
            target: EndPoint,
        ) error{
            InvalidHandle,
            SystemResources,
            AlreadyConnected,
            AlreadyConnecting,
            BufferError,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            OutOfMemory,
            Routing,
            Timeout,
        }!void;

        extern "async" fn Disconnect(socket: UdpSocket) error{
            InvalidHandle,
            SystemResources,
            NotConnected,
        }!void;

        extern "async" fn Send(
            socket: UdpSocket,
            data: []const u8,
        ) error{
            InvalidHandle,
            SystemResources,
            BufferError,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            NotConnected,
            OutOfMemory,
            Routing,
            Timeout,
        }!struct {
            bytes_sent: usize,
        };

        extern "async" fn SendTo(
            socket: UdpSocket,
            receiver: EndPoint,
            data: []const u8,
        ) error{
            InvalidHandle,
            SystemResources,
            BufferError,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            OutOfMemory,
            Routing,
            Timeout,
        }!struct {
            bytes_sent: usize,
        };

        extern "async" fn ReceiveFrom(
            socket: UdpSocket,
            buffer: []u8,
        ) error{
            InvalidHandle,
            SystemResources,
            BufferError,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            OutOfMemory,
            Routing,
            Timeout,
        }!struct {
            bytes_received: usize,
            sender: EndPoint,
        };
    };

    pub const tcp = struct {
        /// Creates a new UDP socket.
        extern fn create_socket() error{SystemResources}!TcpSocket;

        extern "async" fn Bind(
            socket: TcpSocket,
            bind_point: EndPoint,
        ) error{
            InvalidHandle,
            SystemResources,
            AddressInUse,
            IllegalValue,
        }!struct {
            bind_point: EndPoint,
        };

        extern "async" fn Connect(
            socket: TcpSocket,
            target: EndPoint,
        ) error{
            InvalidHandle,
            SystemResources,
            AlreadyConnected,
            AlreadyConnecting,
            BufferError,
            ConnectionAborted,
            ConnectionClosed,
            ConnectionReset,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            OutOfMemory,
            Routing,
            Timeout,
        }!void;

        extern "async" fn Send(
            socket: TcpSocket,
            data: []const u8,
        ) error{
            InvalidHandle,
            SystemResources,
            BufferError,
            ConnectionAborted,
            ConnectionClosed,
            ConnectionReset,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            NotConnected,
            OutOfMemory,
            Routing,
            Timeout,
        }!struct {
            bytes_sent: usize,
        };

        extern "async" fn Receive(
            socket: TcpSocket,
            buffer: []u8,
            /// if true, will read until `buffer.len` bytes arrived. otherwise will read until the end of a single packet
            read_all: bool,
        ) error{
            InvalidHandle,
            SystemResources,
            AlreadyConnected,
            AlreadyConnecting,
            BufferError,
            ConnectionAborted,
            ConnectionClosed,
            ConnectionReset,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            NotConnected,
            OutOfMemory,
            Routing,
            Timeout,
        }!struct {
            bytes_received: usize,
        };
    };
};

/// A file or directory on Ashet OS can be named with any legal UTF-8 sequence
/// that does not contain `/` and `:`. It is recommended to only create file names
/// that are actually typeable on the operating system tho.
///
/// There are some special file names:
/// - `.` is the "current directory" selector and does not add to the path.
/// - `..` is the "parent directory" selector and navigates up in the directory hierarchy if possible.
/// - Any sequence of upper case ASCII letters and digits (`A-Z`, `0-9`) that ends with `:` is a file system name. This name specifies
///   the root directory of a certain file system.
///
/// Paths are either a relative or absolute addyessing of a file system entity.
/// Paths are composed of a sequence of names, each name separated by `/`.
/// A file system name is only legal as the first element of a path sequence, making the path an absolute path.
///
/// There is a limit on how long a file/directory name can be, but there's no limit on how long a total
/// path can be.
///
/// Here are some examples for valid paths:
/// - `example.txt`
/// - `docs/wiki.txt`
/// - `SYS:/apps/editor/code`
/// - `USB0:/foo/../bar` (which is equivalent to `USB0:/bar`)
///
/// The filesystem that is used to boot the OS from has an alias `SYS:` that is always a legal way to address this file system.
pub const fs = struct {
    /// Finds a file system by name
    extern fn find_filesystem(name: []const u8) FileSystemId;

    /// Flushes all open files to disk.
    extern "async" fn Sync() error{DiskError}!void;

    /// Gets information about a file system.
    /// Also returns a `next` id that can be used to iterate over all filesystems.
    /// The `system` filesystem is guaranteed to be the first one.
    extern "async" fn GetFilesystemInfo(fs: FileSystemId) error{
        DiskError,
        InvalidFileSystem,
    }!struct {
        info: FileSystemInfo,
        next: FileSystemId,
    };

    /// opens a directory on a filesystem
    extern "async" fn OpenDrive(fs: FileSystemId, path: []const u8) error{
        DiskError,
        InvalidFileSystem,
        FileNotFound,
        NotADir,
        InvalidPath,
        SystemFdQuotaExceeded,
        SystemResources,
    }!struct {
        dir: Directory,
    };

    /// opens a directory relative to the given dir handle.
    extern "async" fn OpenDir(dir: Directory, path: []const u8) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        NotADir,
        InvalidPath,
        SystemFdQuotaExceeded,
        SystemResources,
    }!struct {
        dir: Directory,
    };

    /// closes the directory handle
    extern "async" fn CloseDir(dir: Directory) error{InvalidHandle}!struct {};

    /// resets the directory iterator to the starting point
    extern "async" fn ResetDirEnumeration(dir: Directory) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!void;

    /// returns the info for the current file or "eof", and advances the iterator to the next entry if possible
    extern "async" fn EnumerateDir(dir: Directory) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!struct {
        eof: bool,
        info: FileInfo,
    };

    /// deletes a file or directory by the given path.
    extern "async" fn Delete(
        dir: Directory,
        path: []const u8,
        recurse: bool,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
    }!void;

    /// creates a new directory relative to dir. If `path` contains subdirectories, all
    /// directories are created.
    extern "async" fn MkDir(
        dir: Directory,
        path: []const u8,
        mkopen: bool,
    ) error{
        DiskError,
        InvalidHandle,
        Exists,
        InvalidPath,
    }!struct {
        dir: Directory,
    };

    /// returns the type of the file/dir at path, also adds size and modification dates
    extern "async" fn StatEntry(
        dir: Directory,
        path_ptr: [*]const u8,
        path_len: usize,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
    }!struct {
        info: FileInfo,
    };

    /// renames a file inside the same file system.
    /// NOTE: This is a cheap operation and does not require the copying of data.
    extern "async" fn NearMove(
        src_dir: Directory,
        src_path: []const u8,
        dst_path: []const u8,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
        Exists,
    }!void;

    # GROUP: modification

    /// moves a file or directory between two unrelated directories. Can also move between different file systems.
    /// NOTE: This syscall might copy the data.
    extern "async" fn FarMove(
        src_dir: Directory,
        src_path: []const u8,
        dst_dir: Directory,
        dst_path: []const u8,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
        Exists,
        NoSpaceLeft,
    }!void;

    /// copies a file or directory between two unrelated directories. Can also move between different file systems.
    extern "async" fn Copy(
        src_dir: Directory,
        src_path: []const u8,
        dst_dir: Directory,
        dst_path: []const u8,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
        Exists,
        NoSpaceLeft,
    }!void;

    # // GROUP: file handling

    /// opens a file from the given directory.
    extern "async" fn OpenFile(
        dir: Directory,
        path: []const u8,
        access: FileAccess,
        mode: FileMode,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
        Exists,
        NoSpaceLeft,
        SystemFdQuotaExceeded,
        SystemResources,
        WriteProtected,
        FileAlreadyExists,
    }!struct {
        handle: File,
    };

    /// closes the handle and flushes the file.
    extern "async" fn CloseFile(file: File) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!void;

    /// makes sure this file is safely stored to mass storage device
    extern "async" fn FlushFile(file: File) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!void;

    /// directly reads data from a given offset into the file. no streaming API to the kernel
    extern "async" fn Read(
        file: File,
        offset: u64,
        buffer: []u8,
    ) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!struct {
        count: usize,
    };

    /// directly writes data to a given offset into the file. no streaming API to the kernel
    extern "async" fn Write(
        file: File,
        offset: u64,
        buffer: []const u8,
    ) error{
        DiskError,
        InvalidHandle,
        NoSpaceLeft,
        SystemResources,
        WriteProtected,
    }!struct {
        count: usize,
    };

    /// allows us to get the current size of the file, modification dates, and so on
    extern "async" fn StatFile(file: File) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!struct {
        info: FileInfo,
    };

    /// Resizes the file to the given length in bytes. Can be also used to truncate a file to zero length.
    extern "async" fn Resize(file: File, length: u64) error{
        DiskError,
        InvalidHandle,
        NoSpaceLeft,
        SystemResources,
    }!void;
};

const shm = struct {
    /// Constructs a new shared memory object with `size` bytes of memory.
    /// Shared memory can be written by all processes without any memory protection.
    extern fn create(size: usize) error{
        SystemResources,
    }!SharedMemory;

    /// Returns the number of bytes inside the given shared memory object.
    extern fn get_length(SharedMemory) usize;

    /// Returns a pointer to the shared memory.
    extern fn get_pointer(SharedMemory) [*]align(16) u8;
};

const pipe = struct {
    /// Spawns a new pipe with `fifo_length` elements of `object_size` bytes.
    /// If `fifo_length` is 0, the pipe is synchronous and can only send data
    /// if a `read` call is active. Otherwise, up to `fifo_length` elements can be
    /// stored in a FIFO.
    extern fn create(object_size: usize, fifo_length: usize) error{
        SystemResources,
    }!Pipe;

    /// Returns the length of the pipe-internal FIFO in elements.
    extern fn get_fifo_length(Pipe) usize;

    /// Returns the size of the objects stored in the pipe.
    extern fn get_object_size(Pipe) usize;

    /// Writes elements from `data` into the given pipe.
    extern "async" fn Write(
        pipe: Pipe,
        /// Pointer to the first element. Length defines how many elements are to be transferred.
        data: []const u8,
        /// Distance between each element in `data`. Can be different from the pipes element size
        /// to allow sparse data to be transferred.
        /// If `0`, it will use the `object_size` property of the pipe.
        stride: usize,
        /// Defines how the write should operate.
        mode: PipeMode,
    ) error{}!struct {
        /// Numbert of elements written into the pipe.
        count: usize,
    };

    /// Reads elements from a pipe into `buffer`.
    extern "async" fn Read(
        pipe: Pipe,
        /// Points to the first element to be received.
        buffer: []u8,
        /// Distance between each element in `buffer`. Can be different from the pipes element size
        /// to allow sparse data to be transferred.
        /// If `0`, it will use the `object_size` property of the pipe.
        stride: usize,
        /// Defines how the read should operate.
        mode: PipeMode,
    ) error{}!struct {
        /// Number of elements read.
        count: usize,
    };
};

const sync = struct {
    /// Creates a new `SyncEvent` object that can be used to synchronize
    /// different processes.
    extern fn create_event() error{SystemResources}!SyncEvent;

    /// Completes one `WaitForEvent` IOP waiting for the given event.
    extern fn notify_one(SyncEvent) void;

    /// Completes all `WaitForEvent` IOP waiting for the given event.
    extern fn notify_all(SyncEvent) void;

    /// Waits for the given `SyncEvent` to be notified.
    extern "async" fn WaitForEvent(SyncEvent) error{}!void;

    /// Creates a new mutual exclusion.
    extern fn create_mutex() error{SystemResources}!Mutex;

    /// Tries to lock a mutex and returns if it was successful.
    extern fn try_lock(Mutex) bool;

    /// Unlocks a mutual exclusion. Completes a single `Lock` IOP if it exists.
    extern fn unlock(Mutex) void;

    /// Locks a mutex. Will complete once the mutex is locked.
    extern "async" fn Lock(Mutex) error{}!void;
};

const draw = struct {
    # Fonts:

    /// Returns the font data for the given font name, if any.
    extern fn get_system_font(font_name: []const u8) error{
        FileNotFound,
        SystemResources,
    }!Font;

    /// Creates a new custom font from the given data.
    extern fn create_font(data: []const u8) error{
        InvalidData,
        SystemResources,
    }!Font;

    /// Returns true if the given font is a system-owned font.
    extern fn is_system_font(Font) bool;

    # Framebuffer management:

    /// Creates a new in-memory framebuffer that can be used for offscreen painting.
    extern fn create_memory_framebuffer(size: Size) error{SystemResources}!Framebuffer;

    /// Creates a new framebuffer based off a video output. Can be used to output pixels
    /// to the screen.
    extern fn create_video_framebuffer(VideoOutput) error{ InvalidHandle, SystemResources }!Framebuffer;

    /// Creates a new framebuffer that allows painting into a GUI window.
    extern fn create_window_framebuffer(Window) error{ InvalidHandle, SystemResources }!Framebuffer;

    /// Creates a new framebuffer that allows painting into a widget.
    extern fn create_widget_framebuffer(Widget) error{ InvalidHandle, SystemResources }!Framebuffer;

    /// Returns the type of a framebuffer object.
    extern fn get_framebuffer_type(Framebuffer) error{InvalidHandle}!FramebufferType;

    /// Returns the size of a framebuffer object.
    extern fn get_framebuffer_size(Framebuffer) error{InvalidHandle}!Size;

    /// Returns the video memory for a *memory* framebuffer.
    /// Other framebuffer types are not allowed to be passed.
    extern fn get_framebuffer_memory(Framebuffer) error{ InvalidHandle, Unsupported }!VideoMemory;

    /// Marks a portion of the framebuffer as changed and forces the OS to
    /// perform an update action if necessary.
    extern fn invalidate_framebuffer(Framebuffer, Rectangle) void;

    # Drawing:

    # TODO: fn annotate_text(*Framebuffer, area: Rectangle, text: []const u8) AnnotationError;

    /// Renders the provided Ashet Graphics Protocol `sequence` into `target` framebuffer.
    ///
    /// The function will run asynchronously and will return as soon as the rendering is done.
    ///
    /// NOTE: On machines without hardware acceleration, this syscall might be completed synchronously.
    extern "async" fn Render(
        /// The framebuffer which should be drawn to.
        target: Framebuffer,
        /// The AGP code that defines the drawing.
        sequence: []const u8,
        /// If the target framebuffer is invalidatable, it is automatically invalidated after the completion
        /// of the command sequence, ensuring presentation of the contents.
        ///
        /// This is useful when painting into widgets or windows to ensure the window manager
        /// actually sees the changes as soon as they are done, reducing graphics pipeline latency.
        auto_invalidate: bool,
    ) error{ InvalidHandle, BadCode }!void;
};

const gui = struct {
    extern fn register_widget_type(*const WidgetDescriptor) error{
        AlreadyRegistered,
        SystemResources,
    }!WidgetType;

    /// Opens a message box popup window and prompts the user for response.
    extern "async" fn ShowMessageBox(
        Desktop,
        message: []const u8,
        caption: []const u8,
        buttons: MessageBoxButtons,
        icon: MessageBoxIcon,
    ) error{}!struct {
        result: MessageBoxResult,
    };

    # Window API:

    /// Spawns a new window.
    extern fn create_window(
        desktop: Desktop,
        title: []const u8,
        min: Size,
        max: Size,
        startup: Size,
        flags: CreateWindowFlags,
    ) error{
        SystemResources,
        InvalidDimensions,
        InvalidHandle,
    }!Window;

    extern fn get_window_title(window: Window, out_title: *[]const u8) error{InvalidHandle}!void;

    extern fn get_window_size(window: Window) error{InvalidHandle}!Size;

    extern fn get_window_min_size(window: Window) error{InvalidHandle}!Size;

    extern fn get_window_max_size(window: Window) error{InvalidHandle}!Size;

    extern fn get_window_flags(window: Window) error{InvalidHandle}!WindowFlags;

    /// Sets the `size` of `window` and returns the new actual size.
    /// NOTE: This event is meant to be used from desktop APIs and will not automatically
    ///       notify the window of the resize event.
    extern fn set_window_size(window: Window, size: Size) error{InvalidHandle}!Size;

    /// Resizes a window to the new size.
    extern fn resize_window(Window, size: Size) void;

    /// Changes a window title.
    extern fn set_window_title(Window, title: []const u8) void;

    /// Notifies the desktop that a window wants attention from the user.
    /// This could just pop the window to the front, make it blink, show a small notification, ...
    extern fn mark_window_urgent(Window) void;

    /// Waits for an event on the given `Window`, completing as soon as
    /// an event arrived.
    extern "async" fn GetWindowEvent(window: Window) error{ InvalidHandle, InProgress, Cancelled }!struct {
        event: WindowEvent,
    };

    # TODO: gui.app_menu

    # Widget API:

    /// Create a new widget identified by `uuid` on the given `window`.
    /// Position and size of the widget are undetermined at start and a call to `place_widget` should be performed on success.
    extern fn create_widget(window: Window, uuid: *const UUID) error{
        SystemResources,
        WidgetNotFound,
    }!Widget;

    /// Moves and resizes a widget in one.
    extern fn place_widget(widget: Widget, position: Point, size: Size) void;

    /// Triggers the `control` event of the widget with the given `message` as a payload.
    extern fn control_widget(widget: Widget, message: WidgetControlMessage) error{
        SystemResources,
    };

    /// Triggers the `widget_notify` event of the `Window` that owns `widget` with `event` as the payload.
    extern fn notify_owner(widget: Widget, event: WidgetNotifyEvent) error{
        SystemResources,
    };

    /// Returns WidgetType-associated "opaque" data for this widget.
    ///
    /// This is meant as a convenience tool to store additional information per widget
    /// like internal state and such.
    ///
    /// The size of this must be known and cannot be queried.
    extern fn get_widget_data(Widget) [*]align(16) u8;

    # Context Menu API:

    # TODO: gui.context_menu

    # Desktop Server API:

    /// Creates a new desktop with the given name.
    extern fn create_desktop(
        /// User-visible name of the desktop.
        name: []const u8,
        descriptor: *const DesktopDescriptor,
    ) error{
        SystemResources,
    }!Desktop;

    # TODO: Function to get the "current"/"primary"/"associated" desktop server, how?

    /// Returns the name of the provided desktop.
    extern fn get_desktop_name(Desktop) error{InvalidHandle}![*:0]const u8;

    /// Enumerates all available desktops.
    extern fn enumerate_desktops(serverlist: ?[]Desktop) usize;

    /// Returns all windows for a desktop handle.
    extern fn enumerate_desktop_windows(Desktop, window: ?[]Window) error{InvalidHandle}!usize;

    /// Returns desktop-associated "opaque" data for this window.
    ///
    /// This is meant as a convenience tool to store additional information per window
    /// like position on the screen, orientation, alignment, ...
    ///
    /// The size of this must be known and cannot be queried.
    extern fn get_desktop_data(Window) error{InvalidHandle}![*]align(16) u8;

    /// Notifies the system that a message box was confirmed by the user.
    ///
    /// **NOTE:** This function is meant to be implemented by a desktop server.
    /// Regular GUI applications should not use this function as they have no
    /// access to a `MessageBoxEvent.RequestID`.
    extern fn notify_message_box(
        /// The desktop that completed the message box.
        source: Desktop,
        /// The request id that was passed in `MessageBoxEvent`.
        request_id: MessageBoxEvent.RequestID,
        /// The resulting button which the user clicked.
        result: MessageBoxResult,
    ) error{ InvalidHandle, BadRequestId }!void;

    /// Posts an event into the window event queue so the window owner
    /// can handle the event.
    extern fn post_window_event(
        window: Window,
        event: WindowEvent,
    ) error{ InvalidHandle, SystemResources };

    /// Sends a notification to the provided `desktop`.
    extern fn send_notification(
        /// Where to show the notification?
        desktop: Desktop,
        /// What text is displayed in the notification?
        message: []const u8,
        /// How urgent is the notification to the user?
        severity: NotificationSeverity,
    ) error{
        SystemResources,
        InvalidHandle,
    };

    const clipboard = struct {
        /// Sets the contents of the clip board.
        /// Takes a mime type as well as the value in the provided format.
        extern fn set(desktop: Desktop, mime: []const u8, value: []const u8) error{
            SystemResources,
        };

        /// Returns the current type present in the clipboard, if any.
        extern fn get_type(desktop: Desktop) ?[*:0]const u8;

        /// Returns the current clipboard value as the provided mime type.
        /// The os provides a conversion *if possible*, otherwise returns an error.
        /// The returned memory for `value` is owned by the process and must be freed with `ashet.process.memory.release`.
        extern fn get_value(desktop: Desktop, mime: []const u8, value: *?[]const u8) error{
            ConversionFailed,
            OutOfMemory,
        };
    };
};

const service = struct {
    /// Registers a new service `uuid` in the system.
    /// Takes an array of function pointers that will be provided for IPC and a service name to be advertised.
    extern fn create(uuid: *const UUID, funcs: []const AbstractFunction, name: []const u8) error{
        AlreadyRegistered,
        SystemResources,
    }!Service;

    /// Enumerates all registered services.
    extern fn enumerate(uuid: *const UUID, services: ?[]Service) usize;

    /// Returns the name of the service.
    extern fn get_name(Service) [*:0]const u8;

    /// Returns the process that created this service.
    extern fn get_process(Service) Process;

    /// Returns the functions registerd by the service.
    extern fn get_functions(Service, funcs: ?[]AbstractFunction) usize;
};

pub const Service = struct(SystemResource) {};

pub const SharedMemory = struct(SystemResource) {};

pub const Pipe = struct(SystemResource) {};

pub const Process = struct(SystemResource) {};

pub const Thread = struct(SystemResource) {};

pub const TcpSocket = struct(SystemResource) {};

pub const UdpSocket = struct(SystemResource) {};

pub const File = struct(SystemResource) {};

pub const Directory = struct(SystemResource) {};

pub const VideoOutput = struct(SystemResource) {};

pub const Font = struct(SystemResource) {};

/// A framebuffer is something that can be drawn on.
pub const Framebuffer = struct(SystemResource) {};

pub const Window = struct(SystemResource) {};

pub const Widget = struct(SystemResource) {};

pub const Desktop = struct(SystemResource) {};

pub const WidgetType = struct(SystemResource) {};

pub const SyncEvent = struct(SystemResource) {};

pub const Mutex = struct(SystemResource) {};

usingnamespace zig; # regular code beyond this

// pub const ARC = extern struct {
//     type: ARC_Type,
//     next: ?*ARC,
//     tag: usize, // user specified data

//     kernel_data: [7]usize = undefined, // internal data used by the kernel to store
// };

/// Constructor for a generic, ABI passable error set.
pub const ErrorSet = @import("error_set").ErrorSet;

/// Asynchronous operations (short AOP) are long-running
/// operations that can run in the background (at least to
/// a certain extend) and can be seen as long-running system
/// calls.
pub const ARC = @import("async_running_call").Generic_ARC(ARC_Type);

pub const platforms = @import("platforms");

pub const Platform = platforms.Platform;
///////////////////////////////////////////////////////////
// Imports:

const std = @import("std");
const abi = @This();

///////////////////////////////////////////////////////////
// Constants:

/// The maximum number of bytes in a file system identifier name.
/// This is chosen to be a power of two, and long enough to accommodate
/// typical file system names:
/// - `SYS`
/// - `USB0`
/// - `USB10`
/// - `PF0`
/// - `CF7`
pub const max_fs_name_len = 8;

/// The maximum number of bytes in a file system type name.
/// Chosen to be a power of two, and long enough to accomodate typical names:
/// - `FAT16`
/// - `FAT32`
/// - `exFAT`
/// - `NTFS`
/// - `ReiserFS`
/// - `ISO 9660`
/// - `btrfs`
/// - `AFFS`
pub const max_fs_type_len = 32;

/// The maximum number of bytes in a file name.
/// This is chosen to be a power of two, and reasonably long.
/// As some programs use sha256 checksums and 64 bytes are enough to store
/// a hex-encoded 256 bit sequence:
/// - `114ac2caf8fefad1116dbfb1bd68429f68e9e088b577c9b3f5a3ff0fe77ec886`
/// This should also enough for most reasonable file names in the wild.
pub const max_file_name_len = 120;

///////////////////////////////////////////////////////////
// System resources:

/// Handle to an abstract system resource.
pub const SystemResource = enum(usize) {
    _,

    /// Casts the resource into a concrete type. Fails, if the type does not match.
    pub fn cast(resource: SystemResource, comptime t: Type) error{ InvalidHandle, InvalidType }!CastResult(t) {
        var actual: Type = undefined;
        if (resources.get_type(resource, &actual) != .ok)
            return error.InvalidHandle;
        if (actual != t)
            return error.InvalidType;
        return resource.unsafe_cast(t);
    }

    /// Casts the resource into a concrete type. Fails, if the type does not match.
    pub fn unsafe_cast(resource: SystemResource, comptime t: Type) CastResult(t) {
        return @ptrFromInt(@intFromEnum(resource));
    }

    fn CastResult(comptime t: Type) type {
        return __SystemResourceCastResult(t);
    }

    pub const Type = __SystemResourceType;

    pub fn format(src: SystemResource, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = options;
        if (fmt.len == 1 and fmt[0] == 'T') {
            var src_type: Type = undefined;
            if (resources.get_type(src, &src_type) == .ok) {
                try writer.print("SystemResource(0x{X:0>8}, type={s})", .{ @intFromEnum(src), @tagName(src_type) });
            } else {
                try writer.print("SystemResource(0x{X:0>8}, bad handle)", .{@intFromEnum(src)});
            }
        } else {
            try writer.print("SystemResource(0x{X:0>8})", .{@intFromEnum(src)});
        }
    }
};


pub const Await_Options = extern struct {
    wait: Wait,
    thread_affinity: Thread_Affinity,

    pub const Thread_Affinity = enum(u8) {
        /// Waits for ARCs scheduled from *any* thread in the current process.
        all_threads,

        /// Waits for ARCs scheduled from *this* thread.
        this_thread,
    };

    pub const Wait = enum(u8) {
        /// Don't wait for any additional calls to complete, just return
        /// whatever was completed in the meantime.
        dont_block = 0,

        /// Wait for at least a single call to complete operation.
        wait_one = 1,

        /// Wait until all scheduled operations have completed.
        ///
        /// This will only wait so long until either
        /// a) all scheduled ops are stored into the result array
        /// or
        /// b) the result array is full
        ///
        /// NOTE: If `thread_affinity` is `.all_threads`, other threads can still
        ///       schedule more operations and make this function block longer.
        wait_all = 2,

        /// Returns whether the operation is blocking or not.
        pub fn isBlocking(wait: Wait) bool {
            return switch (wait) {
                .dont_block => false,
                .wait_one => true,
                .wait_all => true,
            };
        }
    };
};


pub const DesktopEvent = extern union {
    event_type: Type,

    create_window: DesktopWindowEvent,
    destroy_window: DesktopWindowEvent,
    invalidate_window: DesktopWindowInvalidateEvent,

    show_notification: DesktopNotificationEvent,
    show_message_box: MessageBoxEvent,

    pub const Type = enum(u16) {
        // lifecycle management:

        /// A window was created on this desktop.
        create_window = 0,

        /// A window was destroyed on this desktop.
        destroy_window = 1,

        /// A window has been invalidated and must be drawn again.
        invalidate_window = 2,

        // user interaction:

        /// `send_notification` was called and the desktop user should display
        /// a notification.
        show_notification = 3,

        /// `send_notification` was called and the desktop user should display
        /// a notification.
        show_message_box = 4,

        _,
    };

    comptime {
        validate_event_type(@This());
    }
};


pub const InputEvent = extern union {
    event_type: Type,
    mouse: MouseEvent,
    keyboard: KeyboardEvent,

    pub const Type = enum(u16) {
        key_press = 0,
        key_release = 1,

        mouse_rel_motion = 2,
        mouse_abs_motion = 3,
        mouse_button_press = 4,
        mouse_button_release = 5,
    };

    comptime {
        validate_event_type(@This());
    }

};

pub const WidgetEvent = extern union {
    event_type: Type,

    mouse: MouseEvent,
    keyboard: KeyboardEvent,
    control: WidgetControlMessage,

    // TODO: Add event data

    pub const Type = enum(u16) {
        // lifecycle:

        /// The widget was created and attached to a window.
        create = 0,

        /// The widget is in the process of being destroyed.
        /// After this event, the handle will be invalid.
        destroy = 1,

        /// The creator of the widget wants to do something widget-specific.
        control = 2,

        // basic input:

        /// The user clicked on the widget with the primary mouse button
        /// or pressed the return or space bar button on the keyboard.
        click = 3,

        // keyboard input:

        /// A key was pressed on the keyboard.
        key_press = 4,

        /// A key was released on the keyboard.
        key_release = 5,

        // mouse specific extras:

        /// The mouse was moved inside the rectangle of the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_enter = 6,

        /// The mouse was moved outside the rectangle of the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_leave = 7,

        /// The mouse stopped for some time over the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_hover = 8,

        /// A mouse button was pressed over the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_button_press = 9,

        /// A mouse button was released over the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_button_release = 10,

        /// The mouse was moved over the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_motion = 11,

        /// A vertical or horizontal scroll wheel was scrolled over the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        scroll = 12,

        // drag&drop operations:

        /// The user dragged a payload into the rectangle of this widget.
        ///
        /// NOTE: This event can only happen when `allow_drop` was set in the
        /// widget creation flags.
        drag_enter = 13,

        /// The user dragged a payload out of the rectangle of this widget.
        ///
        /// NOTE: This event can only happen when `allow_drop` was set in the
        /// widget type creation flags.
        drag_leave = 14,

        /// The user dragged a payload over the rectangle of this widget.
        ///
        /// NOTE: This event can only happen when `allow_drop` was set in the
        /// widget type creation flags.
        drag_over = 15,

        /// The user dropped a payload into this widget.
        ///
        /// NOTE: This event can only happen when `allow_drop` was set in the
        /// widget type creation flags.
        drag_drop = 16,

        // clipboard operations:

        /// The user requested a clipboard copy operation, usually by pressing 'Ctrl-C'.
        ///
        /// NOTE: This event can only happen when `clipboard_sensitive` was set in
        /// the widget type creation flags.
        clipboard_copy = 17,

        /// The user requested a clipboard paste operation, usually by pressing 'Ctrl-V'.
        ///
        /// NOTE: This event can only happen when `clipboard_sensitive` was set in
        /// the widget type creation flags.
        clipboard_paste = 18,

        /// The user requested a clipboard cut operation, usually by pressing 'Ctrl-X'.
        ///
        /// NOTE: This event can only happen when `clipboard_sensitive` was set in
        /// the widget type creation flags.
        clipboard_cut = 19,

        // widget specific:

        /// The widget was resized with a call to `place_widget`.
        ///
        /// NOTE: This event will not fire if the widget was only moved.
        resized = 21,

        /// The widget should draw itself.
        paint = 20,

        /// User pressed the "context menu" button or did a
        /// secondary mouse button click on the  widget.
        context_menu_request = 22,

        /// The widget received focus via mouse or keyboard.
        focus_enter = 23,

        /// The widget lost focus after receiving it.
        focus_leave = 24,

        _,
    };

    comptime {
        validate_event_type(@This());
    }
};

pub const WindowEvent = extern union {
    event_type: Type,

    mouse: MouseEvent,
    keyboard: KeyboardEvent,
    widget_notify: WidgetNotifyEvent,

    pub const Type = enum(u16) {
        widget_notify = 0,

        key_press = 1,
        key_release = 2,

        mouse_enter = 3,
        mouse_leave = 4,
        mouse_motion = 7,
        mouse_button_press = 6,
        mouse_button_release = 5,

        /// The user requested the window to be closed.
        window_close = 8,

        /// The window was minimized and is not visible anymore.
        window_minimize = 9,

        /// The window was restored from minimized state.
        window_restore = 10,

        /// The window is currently moving on the screen. Query `window.bounds` to get the new position.
        window_moving = 11,

        /// The window was moved on the screen. Query `window.bounds` to get the new position.
        window_moved = 12,

        /// The window size is currently changing. Query `window.bounds` to get the new size.
        window_resizing = 13,

        /// The window size changed. Query `window.bounds` to get the new size.
        window_resized = 14,
    };

    comptime {
        validate_event_type(@This());
    }
};

fn validate_event_type(comptime Event: type) void {
    const union_fields = @typeInfo(Event).@"union".fields;

    // first union field must define our event type:
    std.debug.assert(union_fields[0].type == Event.Type);

    var requires_shared_event_type = false;

    // check that all other fields are extern structs that share
    // the first field with this union:
    for (union_fields[1..]) |fld| {
        const event_type = @typeInfo(fld.type).@"struct";

        const first_field = event_type.fields[0];

        const Msg = [1][]const u8;
        var problems: []const []const u8 = &.{};

        if (event_type.layout != .@"extern") {
            problems = problems ++ &.{"layout not extern"};
        }
        if (first_field.type != Event.Type and first_field.type != SharedEventType) {
            problems = problems ++ Msg{"first field must be either Event.Type or SharedEventType"};
        }
        if (!std.mem.eql(u8, first_field.name, union_fields[0].name)) {
            problems = problems ++ Msg{std.fmt.comptimePrint("first field must be named {}", .{std.zig.fmtId(first_field.name)})};
        }
        if (@offsetOf(fld.type, union_fields[0].name) != 0) {
            problems = problems ++ Msg{std.fmt.comptimePrint("{} must have offset 0", .{std.zig.fmtId(union_fields[0].name)})};
        }

        if (problems.len > 0) {
            var msg: []const u8 = "failed to validate " ++ @typeName(Event) ++ ":";
            for (problems) |problem| {
                msg = msg ++ "\n" ++ problem;
            }
            @compileError(msg);
        }

        if (first_field.type == SharedEventType) {
            requires_shared_event_type = true;
        }
    }

    if (requires_shared_event_type) {
        const in_shared_type = for (@typeInfo(SharedEventType).@"union".fields) |fld| {
            if (fld.type == Event.Type)
                break true;
        } else false;
        if (!in_shared_type)
            @compileError(@typeName(Event.Type) ++ " is not contained in SharedEventType!");
    }
}
