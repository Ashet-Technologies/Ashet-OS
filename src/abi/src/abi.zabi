//!
//! WARNING:
//!     THIS FILE CONTAINS A DSL THAT LOOKS LIKE ZIG BUT NEEDS TO BE
//!     PROCESSED BY `tools/abi-mapper.py` IN ORDER TO BE COMPILABLE!
//!

///////////////////////////////////////////////////////////
// Syscalls & Asynchronous/Overlapped Operations

/// All syscalls related to generic resource management.
const resources = struct {
    /// Returns the type of the system resource.
    extern fn get_type(SystemResource) error{InvalidHandle}!SystemResource.Type;

    /// Returns the current owner of this resource.
    extern fn get_owners(SystemResource, owners: ?[]Process) usize;

    /// Adds the process to the owners of this resource, so the process
    /// can safely access it without fear of having a use-after-free.
    extern fn send_to_process(SystemResource, Process) error{ SystemResources, InvalidHandle, DeadProcess }!void;

    /// Drops the ownership of the resource for the current process.
    /// If no owner remains, the resource will be destroyed and it's
    /// memory will be released.
    /// The handle must be assumed invalid for this process after
    /// this function returns.
    extern fn release(SystemResource) void;

    /// Immediatly destroys the resource and releases its memory.
    ///
    /// NOTE: This will *always* destroy the resource, even if it's
    ///       also owned by another process.
    extern fn destroy(SystemResource) void;
};
const overlapped = struct {
    /// Starts new asynchronous operations.
    ///
    /// NOTE: Until the operation has successfully completed or was
    ///       cancelled, the ARC structure must be considered owned
    ///       by the kernel and must not be changed from userspace.
    ///       It can also change its contents spuriously until the
    ///       operation is returned to userland.
    ///
    extern fn schedule(async_call: *ARC) error{ SystemResources, AlreadyScheduled }!void;

    /// Awaits one or more asynchronous operations and returns the
    /// number of `completed` elements.
    ///
    /// The kernel will fill out `completed` up to the returned number of elements.
    /// All other values are undefined.
    ///
    /// NOTE: For blocking operations, this function will suspend the current
    ///       thread until the request has been completed.
    extern fn await_completion(completed: []*ARC, options: Await_Options) error{Unscheduled}!usize;

    /// Cancels an asynchronous call.
    ///
    /// NOTE: If the operation has already completed, an error will be returned saying so.
    ///
    /// NOTE: The cancelled operation will not be returned by `await` anymore.
    extern fn cancel(aop: *ARC) error{
        Unscheduled,
        Completed,
    }!void;
};

/// Syscalls related to processes
const process = struct {
    /// Returns a pointer to the file name of the process.
    extern fn get_file_name(?Process) [*:0]const u8;

    /// Returns the base address of the process.
    extern fn get_base_address(?Process) usize;

    /// Returns the arguments that were passed to this process in `Spawn`.
    extern fn get_arguments(?Process, argv: ?[]SpawnProcessArg) usize;

    /// Terminates the current process with the given exit code
    extern fn terminate(exit_code: ExitCode) noreturn;

    /// Terminates a foreign process.
    /// If the current process is passed, this function will not return
    extern fn kill(Process) void;

    /// Spawns a new process
    extern "async" fn Spawn(
        /// Relative banse directory for `path`.
        dir: Directory,
        /// File name of the executable relative to `dir`.
        path: []const u8,
        /// The arguments passed to the process.
        /// If a `SystemResource` is passed, it will receive the created process as a owning process.
        /// It is safe to release the resource in this process as soon as this operation returns.
        argv: []const SpawnProcessArg,
    ) error{
        SystemResources,
        FileNotFound,
        InvalidPath,
        BadExecutable,
        InvalidHandle,
        DiskError,
    }!struct {
        /// Handle to the spawned process.
        process: Process,
    };

    const thread = struct {
        /// Returns control to the scheduler. Returns when the scheduler
        /// schedules the process again.
        extern fn yield() void;

        /// Terminates the current thread.
        extern fn exit(exit_code: ExitCode) noreturn;

        /// Waits for the thread to exit and returns its return code.
        extern fn join(Thread) ExitCode;

        /// Spawns a new thread with `function` passing `arg` to it.
        /// If `stack_size` is not 0, will create a stack with the given size.
        extern fn spawn(function: ThreadFunction, arg: ?*anyopaque, stack_size: usize) ?Thread;

        /// Kills the given thread with `exit_code`.
        extern fn kill(Thread, exit_code: ExitCode) void;
    };

    const debug = struct {
        /// Writes to the system debug log.
        extern fn write_log(log_level: LogLevel, message: []const u8) void;

        /// Stops the process and allows debugging.
        extern fn breakpoint() void;
    };

    const memory = struct {
        /// Allocates memory
        extern fn allocate(size: usize, ptr_align: u8) ?[*]u8;

        /// Returns memory to the systme.
        extern fn release(mem: []u8, ptr_align: u8) void;
    };

    const monitor = struct {
        /// Queries all owned resources by a process.
        extern fn enumerate_processes(processes: ?[]Process) usize;

        /// Queries all owned resources by a process.
        extern fn query_owned_resources(owner: Process, reslist: ?[]SystemResource) usize;

        /// Returns the total number of bytes the process takes up in RAM.
        extern fn query_total_memory_usage(proc: Process) usize;

        /// Returns the number of dynamically allocated bytes for this process.
        extern fn query_dynamic_memory_usage(proc: Process) usize;

        /// Returns the number of total memory objects this process has right now.
        extern fn query_active_allocation_count(proc: Process) usize;
    };
};

const clock = struct {
    /// Returns the time in nanoseconds since system startup.
    /// This clock is monotonically increasing.
    extern fn monotonic() Absolute;

    /// Sleeps until `clock.monotonic()` returns at least `timeout`.
    extern "async" fn Timer(
        /// Monotonic timestamp in nanoseconds until the operation completes.
        timeout: Absolute,
    ) error{}!void;
};

const datetime = struct {
    /// Get a calendar timestamp relative to UTC 1970-01-01.
    /// Precision of timing depends on the hardware.
    /// The return value is signed because it is possible to have a date that is
    /// before the epoch.
    extern fn now() DateTime;

    /// Sleeps until `datetime.now()` returns a point in  time that comes after `when`.
    extern "async" fn Alarm(
        /// Earliest possible date time of when the alarm triggers.
        when: DateTime,
    ) error{}!void;
};

const video = struct {
    /// Returns a list of all video outputs.
    ///
    /// If `ids` is `null`, the total number of available outputs is returned,
    /// otherwise, up to `ids.len` elements are written into the provided array
    /// and the number of written elements is returned.
    extern fn enumerate(ids: ?[]VideoOutputID) usize;

    /// Acquire exclusive access to a video output.
    extern fn acquire(VideoOutputID) error{
        SystemResources,
        NotFound,
        NotAvailable,
    }!VideoOutput;

    /// Returns the current resolution
    extern fn get_resolution(VideoOutput) error{InvalidHandle}!Size;

    /// Returns a pointer to linear video memory, row-major.
    /// Pixels rows will have a stride of the current video buffer width.
    /// The first pixel in the memory is the top-left pixel.
    extern fn get_video_memory(VideoOutput) error{InvalidHandle}!VideoMemory;

    /// Fetches a copy of the current color pallete.
    extern fn get_palette(VideoOutput, *[palette_size]Color) error{InvalidHandle}!void;

    /// Changes the current color palette.
    extern fn set_palette(VideoOutput, *const [palette_size]Color) error{ InvalidHandle, Unsupported };

    // /// Returns a pointer to the current palette. Changing this palette
    // /// will directly change the associated colors on the screen.
    // /// If `null` is returned, no direct access to the video palette is possible.
    //  fn get_palette_memory(*VideoOutput) ?*[palette_size]Color;

    // /// Changes the border color of the screen. Parameter is an index into
    // /// the palette.
    //  fn set_border(*VideoOutput, ColorIndex) void;

    // /// Returns the maximum possible screen resolution.
    //  fn get_max_resolution(*VideoOutput) Size;

    // /// Sets the screen resolution. Legal values are between 1Ã—1 and the platform specific
    // /// maximum resolution returned by `video.getMaxResolution()`.
    // /// Everything out of bounds will be clamped into that range.
    //  fn change_resolution(*VideoOutput, u16, u16) void;
};

const random = struct {
    /// Fills the provided pointer with random bytes from the entropy pool.
    ///
    /// If the entropy pool runs out of entropy bits, this call does not block
    /// and draw bytes from the pool.
    extern fn get_soft_random(data: []u8) void;

    /// Fills the provided buffer with given length amount of random bytes.
    ///
    /// This call blocks until the entropy pool has enough entropy to fill
    /// an entire hash to draw from.
    extern "async" fn GetStrictRandom(data: []u8) error{}!void;
};

const input = struct {
    /// Waits for an input event and completes when any input was done.
    extern "async" fn GetEvent() error{
        NonExclusiveAccess,
        InProgress,
    }!struct {
        event: InputEvent,
    };
};

const network = struct {
    // getStatus: FnPtr(fn () NetworkStatus),
    // ping: FnPtr(fn ([*]Ping, usize) void),
    // TODO: Implement NIC-specific queries (mac, ips, names, ...)

    const dns = struct {
        // resolves the dns entry `host` for the given `service`.
        // - `host` is a legal dns entry
        // - `port` is either a port number
        // - `buffer` and `limit` define a structure where all resolved IPs can be stored.
        // Function returns the number of host entries found or 0 if the host name could not be resolved.
        //  fn @"resolve" (host: [*:0]const u8, port: u16, buffer: [*]EndPoint, limit: usize) usize;

    };

    pub const udp = struct {
        /// Creates a new TCP socket.
        extern fn create_socket() error{SystemResources}!UdpSocket;

        extern "async" fn Bind(socket: UdpSocket, bind_point: EndPoint) error{
            InvalidHandle,
            SystemResources,
            AddressInUse,
            IllegalValue,
        }!struct {
            bind_point: EndPoint,
        };

        extern "async" fn Connect(
            socket: UdpSocket,
            target: EndPoint,
        ) error{
            InvalidHandle,
            SystemResources,
            AlreadyConnected,
            AlreadyConnecting,
            BufferError,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            OutOfMemory,
            Routing,
            Timeout,
        }!void;

        extern "async" fn Disconnect(socket: UdpSocket) error{
            InvalidHandle,
            SystemResources,
            NotConnected,
        }!void;

        extern "async" fn Send(
            socket: UdpSocket,
            data: []const u8,
        ) error{
            InvalidHandle,
            SystemResources,
            BufferError,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            NotConnected,
            OutOfMemory,
            Routing,
            Timeout,
        }!struct {
            bytes_sent: usize,
        };

        extern "async" fn SendTo(
            socket: UdpSocket,
            receiver: EndPoint,
            data: []const u8,
        ) error{
            InvalidHandle,
            SystemResources,
            BufferError,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            OutOfMemory,
            Routing,
            Timeout,
        }!struct {
            bytes_sent: usize,
        };

        extern "async" fn ReceiveFrom(
            socket: UdpSocket,
            buffer: []u8,
        ) error{
            InvalidHandle,
            SystemResources,
            BufferError,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            OutOfMemory,
            Routing,
            Timeout,
        }!struct {
            bytes_received: usize,
            sender: EndPoint,
        };
    };

    pub const tcp = struct {
        /// Creates a new UDP socket.
        extern fn create_socket() error{SystemResources}!TcpSocket;

        extern "async" fn Bind(
            socket: TcpSocket,
            bind_point: EndPoint,
        ) error{
            InvalidHandle,
            SystemResources,
            AddressInUse,
            IllegalValue,
        }!struct {
            bind_point: EndPoint,
        };

        extern "async" fn Connect(
            socket: TcpSocket,
            target: EndPoint,
        ) error{
            InvalidHandle,
            SystemResources,
            AlreadyConnected,
            AlreadyConnecting,
            BufferError,
            ConnectionAborted,
            ConnectionClosed,
            ConnectionReset,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            OutOfMemory,
            Routing,
            Timeout,
        }!void;

        extern "async" fn Send(
            socket: TcpSocket,
            data: []const u8,
        ) error{
            InvalidHandle,
            SystemResources,
            BufferError,
            ConnectionAborted,
            ConnectionClosed,
            ConnectionReset,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            NotConnected,
            OutOfMemory,
            Routing,
            Timeout,
        }!struct {
            bytes_sent: usize,
        };

        extern "async" fn Receive(
            socket: TcpSocket,
            buffer: []u8,
            /// if true, will read until `buffer.len` bytes arrived. otherwise will read until the end of a single packet
            read_all: bool,
        ) error{
            InvalidHandle,
            SystemResources,
            AlreadyConnected,
            AlreadyConnecting,
            BufferError,
            ConnectionAborted,
            ConnectionClosed,
            ConnectionReset,
            IllegalArgument,
            IllegalValue,
            InProgress,
            LowlevelInterfaceError,
            NotConnected,
            OutOfMemory,
            Routing,
            Timeout,
        }!struct {
            bytes_received: usize,
        };
    };
};

/// A file or directory on Ashet OS can be named with any legal UTF-8 sequence
/// that does not contain `/` and `:`. It is recommended to only create file names
/// that are actually typeable on the operating system tho.
///
/// There are some special file names:
/// - `.` is the "current directory" selector and does not add to the path.
/// - `..` is the "parent directory" selector and navigates up in the directory hierarchy if possible.
/// - Any sequence of upper case ASCII letters and digits (`A-Z`, `0-9`) that ends with `:` is a file system name. This name specifies
///   the root directory of a certain file system.
///
/// Paths are either a relative or absolute addyessing of a file system entity.
/// Paths are composed of a sequence of names, each name separated by `/`.
/// A file system name is only legal as the first element of a path sequence, making the path an absolute path.
///
/// There is a limit on how long a file/directory name can be, but there's no limit on how long a total
/// path can be.
///
/// Here are some examples for valid paths:
/// - `example.txt`
/// - `docs/wiki.txt`
/// - `SYS:/apps/editor/code`
/// - `USB0:/foo/../bar` (which is equivalent to `USB0:/bar`)
///
/// The filesystem that is used to boot the OS from has an alias `SYS:` that is always a legal way to address this file system.
pub const fs = struct {
    /// Finds a file system by name
    extern fn find_filesystem(name: []const u8) FileSystemId;

    /// Flushes all open files to disk.
    extern "async" fn Sync() error{DiskError}!void;

    /// Gets information about a file system.
    /// Also returns a `next` id that can be used to iterate over all filesystems.
    /// The `system` filesystem is guaranteed to be the first one.
    extern "async" fn GetFilesystemInfo(fs: FileSystemId) error{
        DiskError,
        InvalidFileSystem,
    }!struct {
        info: FileSystemInfo,
        next: FileSystemId,
    };

    /// opens a directory on a filesystem
    extern "async" fn OpenDrive(fs: FileSystemId, path: []const u8) error{
        DiskError,
        InvalidFileSystem,
        FileNotFound,
        NotADir,
        InvalidPath,
        SystemFdQuotaExceeded,
        SystemResources,
    }!struct {
        dir: Directory,
    };

    /// opens a directory relative to the given dir handle.
    extern "async" fn OpenDir(dir: Directory, path: []const u8) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        NotADir,
        InvalidPath,
        SystemFdQuotaExceeded,
        SystemResources,
    }!struct {
        dir: Directory,
    };

    /// closes the directory handle
    extern "async" fn CloseDir(dir: Directory) error{InvalidHandle}!struct {};

    /// resets the directory iterator to the starting point
    extern "async" fn ResetDirEnumeration(dir: Directory) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!void;

    /// returns the info for the current file or "eof", and advances the iterator to the next entry if possible
    extern "async" fn EnumerateDir(dir: Directory) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!struct {
        eof: bool,
        info: FileInfo,
    };

    /// deletes a file or directory by the given path.
    extern "async" fn Delete(
        dir: Directory,
        path: []const u8,
        recurse: bool,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
    }!void;

    /// creates a new directory relative to dir. If `path` contains subdirectories, all
    /// directories are created.
    extern "async" fn MkDir(
        dir: Directory,
        path: []const u8,
        mkopen: bool,
    ) error{
        DiskError,
        InvalidHandle,
        Exists,
        InvalidPath,
    }!struct {
        dir: Directory,
    };

    /// returns the type of the file/dir at path, also adds size and modification dates
    extern "async" fn StatEntry(
        dir: Directory,
        path_ptr: [*]const u8,
        path_len: usize,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
    }!struct {
        info: FileInfo,
    };

    /// renames a file inside the same file system.
    /// NOTE: This is a cheap operation and does not require the copying of data.
    extern "async" fn NearMove(
        src_dir: Directory,
        src_path: []const u8,
        dst_path: []const u8,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
        Exists,
    }!void;

    // GROUP: modification

    /// moves a file or directory between two unrelated directories. Can also move between different file systems.
    /// NOTE: This syscall might copy the data.
    extern "async" fn FarMove(
        src_dir: Directory,
        src_path: []const u8,
        dst_dir: Directory,
        dst_path: []const u8,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
        Exists,
        NoSpaceLeft,
    }!void;

    /// copies a file or directory between two unrelated directories. Can also move between different file systems.
    extern "async" fn Copy(
        src_dir: Directory,
        src_path: []const u8,
        dst_dir: Directory,
        dst_path: []const u8,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
        Exists,
        NoSpaceLeft,
    }!void;

    // // GROUP: file handling

    /// opens a file from the given directory.
    extern "async" fn OpenFile(
        dir: Directory,
        path: []const u8,
        access: FileAccess,
        mode: FileMode,
    ) error{
        DiskError,
        InvalidHandle,
        FileNotFound,
        InvalidPath,
        Exists,
        NoSpaceLeft,
        SystemFdQuotaExceeded,
        SystemResources,
        WriteProtected,
        FileAlreadyExists,
    }!struct {
        handle: File,
    };

    /// closes the handle and flushes the file.
    extern "async" fn CloseFile(file: File) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!void;

    /// makes sure this file is safely stored to mass storage device
    extern "async" fn FlushFile(file: File) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!void;

    /// directly reads data from a given offset into the file. no streaming API to the kernel
    extern "async" fn Read(
        file: File,
        offset: u64,
        buffer: []u8,
    ) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!struct {
        count: usize,
    };

    /// directly writes data to a given offset into the file. no streaming API to the kernel
    extern "async" fn Write(
        file: File,
        offset: u64,
        buffer: []const u8,
    ) error{
        DiskError,
        InvalidHandle,
        NoSpaceLeft,
        SystemResources,
        WriteProtected,
    }!struct {
        count: usize,
    };

    /// allows us to get the current size of the file, modification dates, and so on
    extern "async" fn StatFile(file: File) error{
        DiskError,
        InvalidHandle,
        SystemResources,
    }!struct {
        info: FileInfo,
    };

    /// Resizes the file to the given length in bytes. Can be also used to truncate a file to zero length.
    extern "async" fn Resize(file: File, length: u64) error{
        DiskError,
        InvalidHandle,
        NoSpaceLeft,
        SystemResources,
    }!void;
};

const shm = struct {
    /// Constructs a new shared memory object with `size` bytes of memory.
    /// Shared memory can be written by all processes without any memory protection.
    extern fn create(size: usize) error{
        SystemResources,
    }!SharedMemory;

    /// Returns the number of bytes inside the given shared memory object.
    extern fn get_length(SharedMemory) usize;

    /// Returns a pointer to the shared memory.
    extern fn get_pointer(SharedMemory) [*]align(16) u8;
};

const pipe = struct {
    /// Spawns a new pipe with `fifo_length` elements of `object_size` bytes.
    /// If `fifo_length` is 0, the pipe is synchronous and can only send data
    /// if a `read` call is active. Otherwise, up to `fifo_length` elements can be
    /// stored in a FIFO.
    extern fn create(object_size: usize, fifo_length: usize) error{
        SystemResources,
    }!Pipe;

    /// Returns the length of the pipe-internal FIFO in elements.
    extern fn get_fifo_length(Pipe) usize;

    /// Returns the size of the objects stored in the pipe.
    extern fn get_object_size(Pipe) usize;

    /// Writes elements from `data` into the given pipe.
    extern "async" fn Write(
        pipe: Pipe,
        /// Pointer to the first element. Length defines how many elements are to be transferred.
        data: []const u8,
        /// Distance between each element in `data`. Can be different from the pipes element size
        /// to allow sparse data to be transferred.
        /// If `0`, it will use the `object_size` property of the pipe.
        stride: usize,
        /// Defines how the write should operate.
        mode: PipeMode,
    ) error{}!struct {
        /// Numbert of elements written into the pipe.
        count: usize,
    };

    /// Reads elements from a pipe into `buffer`.
    extern "async" fn Read(
        pipe: Pipe,
        /// Points to the first element to be received.
        buffer: []u8,
        /// Distance between each element in `buffer`. Can be different from the pipes element size
        /// to allow sparse data to be transferred.
        /// If `0`, it will use the `object_size` property of the pipe.
        stride: usize,
        /// Defines how the read should operate.
        mode: PipeMode,
    ) error{}!struct {
        /// Number of elements read.
        count: usize,
    };
};

const sync = struct {
    /// Creates a new `SyncEvent` object that can be used to synchronize
    /// different processes.
    extern fn create_event() error{SystemResources}!SyncEvent;

    /// Completes one `WaitForEvent` IOP waiting for the given event.
    extern fn notify_one(SyncEvent) void;

    /// Completes all `WaitForEvent` IOP waiting for the given event.
    extern fn notify_all(SyncEvent) void;

    /// Waits for the given `SyncEvent` to be notified.
    extern "async" fn WaitForEvent(SyncEvent) error{}!void;

    /// Creates a new mutual exclusion.
    extern fn create_mutex() error{SystemResources}!Mutex;

    /// Tries to lock a mutex and returns if it was successful.
    extern fn try_lock(Mutex) bool;

    /// Unlocks a mutual exclusion. Completes a single `Lock` IOP if it exists.
    extern fn unlock(Mutex) void;

    /// Locks a mutex. Will complete once the mutex is locked.
    extern "async" fn Lock(Mutex) error{}!void;
};

const draw = struct {
    // Fonts:

    /// Returns the font data for the given font name, if any.
    extern fn get_system_font(font_name: []const u8) error{
        FileNotFound,
        SystemResources,
    }!Font;

    /// Creates a new custom font from the given data.
    extern fn create_font(data: []const u8) error{
        InvalidData,
        SystemResources,
    }!Font;

    /// Returns true if the given font is a system-owned font.
    extern fn is_system_font(Font) bool;

    // Framebuffer management:

    /// Creates a new in-memory framebuffer that can be used for offscreen painting.
    extern fn create_memory_framebuffer(size: Size) error{SystemResources}!Framebuffer;

    /// Creates a new framebuffer based off a video output. Can be used to output pixels
    /// to the screen.
    extern fn create_video_framebuffer(VideoOutput) error{ InvalidHandle, SystemResources }!Framebuffer;

    /// Creates a new framebuffer that allows painting into a GUI window.
    extern fn create_window_framebuffer(Window) error{ InvalidHandle, SystemResources }!Framebuffer;

    /// Creates a new framebuffer that allows painting into a widget.
    extern fn create_widget_framebuffer(Widget) error{ InvalidHandle, SystemResources }!Framebuffer;

    /// Returns the type of a framebuffer object.
    extern fn get_framebuffer_type(Framebuffer) error{InvalidHandle}!FramebufferType;

    /// Returns the size of a framebuffer object.
    extern fn get_framebuffer_size(Framebuffer) error{InvalidHandle}!Size;

    /// Returns the video memory for a *memory* framebuffer.
    /// Other framebuffer types are not allowed to be passed.
    extern fn get_framebuffer_memory(Framebuffer) error{ InvalidHandle, Unsupported }!VideoMemory;

    /// Marks a portion of the framebuffer as changed and forces the OS to
    /// perform an update action if necessary.
    extern fn invalidate_framebuffer(Framebuffer, Rectangle) void;

    // Drawing:

    // TODO: fn annotate_text(*Framebuffer, area: Rectangle, text: []const u8) AnnotationError;

    /// Renders the provided Ashet Graphics Protocol `sequence` into `target` framebuffer.
    ///
    /// The function will run asynchronously and will return as soon as the rendering is done.
    ///
    /// NOTE: On machines without hardware acceleration, this syscall might be completed synchronously.
    extern "async" fn Render(
        /// The framebuffer which should be drawn to.
        target: Framebuffer,
        /// The AGP code that defines the drawing.
        sequence: []const u8,
        /// If the target framebuffer is invalidatable, it is automatically invalidated after the completion
        /// of the command sequence, ensuring presentation of the contents.
        ///
        /// This is useful when painting into widgets or windows to ensure the window manager
        /// actually sees the changes as soon as they are done, reducing graphics pipeline latency.
        auto_invalidate: bool,
    ) error{ InvalidHandle, BadCode }!void;
};

const gui = struct {
    extern fn register_widget_type(*const WidgetDescriptor) error{
        AlreadyRegistered,
        SystemResources,
    }!WidgetType;

    /// Opens a message box popup window and prompts the user for response.
    extern "async" fn ShowMessageBox(
        Desktop,
        message: []const u8,
        caption: []const u8,
        buttons: MessageBoxButtons,
        icon: MessageBoxIcon,
    ) error{}!struct {
        result: MessageBoxResult,
    };

    // Window API:

    /// Spawns a new window.
    extern fn create_window(
        desktop: Desktop,
        title: []const u8,
        min: Size,
        max: Size,
        startup: Size,
        flags: CreateWindowFlags,
    ) error{
        SystemResources,
        InvalidDimensions,
        InvalidHandle,
    }!Window;

    extern fn get_window_title(window: Window, out_title: *[]const u8) error{InvalidHandle}!void;

    extern fn get_window_size(window: Window) error{InvalidHandle}!Size;

    extern fn get_window_min_size(window: Window) error{InvalidHandle}!Size;

    extern fn get_window_max_size(window: Window) error{InvalidHandle}!Size;

    extern fn get_window_flags(window: Window) error{InvalidHandle}!WindowFlags;

    /// Sets the `size` of `window` and returns the new actual size.
    /// NOTE: This event is meant to be used from desktop APIs and will not automatically
    ///       notify the window of the resize event.
    extern fn set_window_size(window: Window, size: Size) error{InvalidHandle}!Size;

    /// Resizes a window to the new size.
    extern fn resize_window(Window, size: Size) void;

    /// Changes a window title.
    extern fn set_window_title(Window, title: []const u8) void;

    /// Notifies the desktop that a window wants attention from the user.
    /// This could just pop the window to the front, make it blink, show a small notification, ...
    extern fn mark_window_urgent(Window) void;

    /// Waits for an event on the given `Window`, completing as soon as
    /// an event arrived.
    extern "async" fn GetWindowEvent(window: Window) error{ InvalidHandle, InProgress, Cancelled }!struct {
        event: WindowEvent,
    };

    // TODO: gui.app_menu

    // Widget API:

    /// Create a new widget identified by `uuid` on the given `window`.
    /// Position and size of the widget are undetermined at start and a call to `place_widget` should be performed on success.
    extern fn create_widget(window: Window, uuid: *const UUID) error{
        SystemResources,
        WidgetNotFound,
    }!Widget;

    /// Moves and resizes a widget in one.
    extern fn place_widget(widget: Widget, position: Point, size: Size) void;

    /// Triggers the `control` event of the widget with the given `message` as a payload.
    extern fn control_widget(widget: Widget, message: WidgetControlMessage) error{
        SystemResources,
    };

    /// Triggers the `widget_notify` event of the `Window` that owns `widget` with `event` as the payload.
    extern fn notify_owner(widget: Widget, event: WidgetNotifyEvent) error{
        SystemResources,
    };

    /// Returns WidgetType-associated "opaque" data for this widget.
    ///
    /// This is meant as a convenience tool to store additional information per widget
    /// like internal state and such.
    ///
    /// The size of this must be known and cannot be queried.
    extern fn get_widget_data(Widget) [*]align(16) u8;

    // Context Menu API:

    // TODO: gui.context_menu

    // Desktop Server API:

    /// Creates a new desktop with the given name.
    extern fn create_desktop(
        /// User-visible name of the desktop.
        name: []const u8,
        descriptor: *const DesktopDescriptor,
    ) error{
        SystemResources,
    }!Desktop;

    // TODO: Function to get the "current"/"primary"/"associated" desktop server, how?

    /// Returns the name of the provided desktop.
    extern fn get_desktop_name(Desktop) error{InvalidHandle}![*:0]const u8;

    /// Enumerates all available desktops.
    extern fn enumerate_desktops(serverlist: ?[]Desktop) usize;

    /// Returns all windows for a desktop handle.
    extern fn enumerate_desktop_windows(Desktop, window: ?[]Window) error{InvalidHandle}!usize;

    /// Returns desktop-associated "opaque" data for this window.
    ///
    /// This is meant as a convenience tool to store additional information per window
    /// like position on the screen, orientation, alignment, ...
    ///
    /// The size of this must be known and cannot be queried.
    extern fn get_desktop_data(Window) error{InvalidHandle}![*]align(16) u8;

    /// Notifies the system that a message box was confirmed by the user.
    ///
    /// **NOTE:** This function is meant to be implemented by a desktop server.
    /// Regular GUI applications should not use this function as they have no
    /// access to a `MessageBoxEvent.RequestID`.
    extern fn notify_message_box(
        /// The desktop that completed the message box.
        source: Desktop,
        /// The request id that was passed in `MessageBoxEvent`.
        request_id: MessageBoxEvent.RequestID,
        /// The resulting button which the user clicked.
        result: MessageBoxResult,
    ) error{ InvalidHandle, BadRequestId }!void;

    /// Posts an event into the window event queue so the window owner
    /// can handle the event.
    extern fn post_window_event(
        window: Window,
        event: WindowEvent,
    ) error{ InvalidHandle, SystemResources };

    /// Sends a notification to the provided `desktop`.
    extern fn send_notification(
        /// Where to show the notification?
        desktop: Desktop,
        /// What text is displayed in the notification?
        message: []const u8,
        /// How urgent is the notification to the user?
        severity: NotificationSeverity,
    ) error{
        SystemResources,
        InvalidHandle,
    };

    const clipboard = struct {
        /// Sets the contents of the clip board.
        /// Takes a mime type as well as the value in the provided format.
        extern fn set(desktop: Desktop, mime: []const u8, value: []const u8) error{
            SystemResources,
        };

        /// Returns the current type present in the clipboard, if any.
        extern fn get_type(desktop: Desktop) ?[*:0]const u8;

        /// Returns the current clipboard value as the provided mime type.
        /// The os provides a conversion *if possible*, otherwise returns an error.
        /// The returned memory for `value` is owned by the process and must be freed with `ashet.process.memory.release`.
        extern fn get_value(desktop: Desktop, mime: []const u8, value: *?[]const u8) error{
            ConversionFailed,
            OutOfMemory,
        };
    };
};

const service = struct {
    /// Registers a new service `uuid` in the system.
    /// Takes an array of function pointers that will be provided for IPC and a service name to be advertised.
    extern fn create(uuid: *const UUID, funcs: []const AbstractFunction, name: []const u8) error{
        AlreadyRegistered,
        SystemResources,
    }!Service;

    /// Enumerates all registered services.
    extern fn enumerate(uuid: *const UUID, services: ?[]Service) usize;

    /// Returns the name of the service.
    extern fn get_name(Service) [*:0]const u8;

    /// Returns the process that created this service.
    extern fn get_process(Service) Process;

    /// Returns the functions registerd by the service.
    extern fn get_functions(Service, funcs: ?[]AbstractFunction) usize;
};

pub const Service = struct(SystemResource) {};

pub const SharedMemory = struct(SystemResource) {};

pub const Pipe = struct(SystemResource) {};

pub const Process = struct(SystemResource) {};

pub const Thread = struct(SystemResource) {};

pub const TcpSocket = struct(SystemResource) {};

pub const UdpSocket = struct(SystemResource) {};

pub const File = struct(SystemResource) {};

pub const Directory = struct(SystemResource) {};

pub const VideoOutput = struct(SystemResource) {};

pub const Font = struct(SystemResource) {};

/// A framebuffer is something that can be drawn on.
pub const Framebuffer = struct(SystemResource) {};

pub const Window = struct(SystemResource) {};

pub const Widget = struct(SystemResource) {};

pub const Desktop = struct(SystemResource) {};

pub const WidgetType = struct(SystemResource) {};

pub const SyncEvent = struct(SystemResource) {};

pub const Mutex = struct(SystemResource) {};

usingnamespace zig; // regular code beyond this

// pub const ARC = extern struct {
//     type: ARC_Type,
//     next: ?*ARC,
//     tag: usize, // user specified data

//     kernel_data: [7]usize = undefined, // internal data used by the kernel to store
// };

/// Constructor for a generic, ABI passable error set.
pub const ErrorSet = @import("error_set").ErrorSet;

/// Asynchronous operations (short AOP) are long-running
/// operations that can run in the background (at least to
/// a certain extend) and can be seen as long-running system
/// calls.
pub const ARC = @import("async_running_call").Generic_ARC(ARC_Type);

pub const platforms = @import("platforms");

pub const Platform = platforms.Platform;
///////////////////////////////////////////////////////////
// Imports:

const std = @import("std");
const abi = @This();

///////////////////////////////////////////////////////////
// Constants:

/// The maximum number of bytes in a file system identifier name.
/// This is chosen to be a power of two, and long enough to accommodate
/// typical file system names:
/// - `SYS`
/// - `USB0`
/// - `USB10`
/// - `PF0`
/// - `CF7`
pub const max_fs_name_len = 8;

/// The maximum number of bytes in a file system type name.
/// Chosen to be a power of two, and long enough to accomodate typical names:
/// - `FAT16`
/// - `FAT32`
/// - `exFAT`
/// - `NTFS`
/// - `ReiserFS`
/// - `ISO 9660`
/// - `btrfs`
/// - `AFFS`
pub const max_fs_type_len = 32;

/// The maximum number of bytes in a file name.
/// This is chosen to be a power of two, and reasonably long.
/// As some programs use sha256 checksums and 64 bytes are enough to store
/// a hex-encoded 256 bit sequence:
/// - `114ac2caf8fefad1116dbfb1bd68429f68e9e088b577c9b3f5a3ff0fe77ec886`
/// This should also enough for most reasonable file names in the wild.
pub const max_file_name_len = 120;

pub const palette_size = std.math.maxInt(@typeInfo(ColorIndex).Enum.tag_type) + 1;

///////////////////////////////////////////////////////////
// System resources:

/// Handle to an abstract system resource.
pub const SystemResource = enum(usize) {
    _,

    /// Casts the resource into a concrete type. Fails, if the type does not match.
    pub fn cast(resource: SystemResource, comptime t: Type) error{ InvalidHandle, InvalidType }!CastResult(t) {
        var actual: Type = undefined;
        if (resources.get_type(resource, &actual) != .ok)
            return error.InvalidHandle;
        if (actual != t)
            return error.InvalidType;
        return resource.unsafe_cast(t);
    }

    /// Casts the resource into a concrete type. Fails, if the type does not match.
    pub fn unsafe_cast(resource: SystemResource, comptime t: Type) CastResult(t) {
        return @ptrFromInt(@intFromEnum(resource));
    }

    fn CastResult(comptime t: Type) type {
        return __SystemResourceCastResult(t);
    }

    pub const Type = __SystemResourceType;

    pub fn format(src: SystemResource, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = options;
        if (fmt.len == 1 and fmt[0] == 'T') {
            var src_type: Type = undefined;
            if (resources.get_type(src, &src_type) == .ok) {
                try writer.print("SystemResource(0x{X:0>8}, type={s})", .{ @intFromEnum(src), @tagName(src_type) });
            } else {
                try writer.print("SystemResource(0x{X:0>8}, bad handle)", .{@intFromEnum(src)});
            }
        } else {
            try writer.print("SystemResource(0x{X:0>8})", .{@intFromEnum(src)});
        }
    }
};

///////////////////////////////////////////////////////////
// Simple types:

pub const UUID = extern struct {
    bytes: [16]u8,

    /// Parses a UUID in the format
    /// `3ad20402-1711-4bbc-b6c3-ff8a1da068c6`
    /// and returns a pointer to it.
    ///
    /// You can generate UUIDs at
    /// https://www.uuidgenerator.net/version4
    pub fn constant(str: *const [36:0]u8) *const UUID {
        _ = str;
        unreachable;
    }
};

pub const MAC = [6]u8;

pub const AbstractFunction = *const fn () callconv(.C) void;

pub const ThreadFunction = *const fn (?*anyopaque) callconv(.C) u32;

/// A date-and-time type encoding the time point in question as a
/// Unix timestamp in milliseconds
pub const DateTime = enum(i64) {
    /// 1970-01-01 00:00
    epoch = 0,

    _,

    pub fn as_unix_timestamp_ms(dt: DateTime) i64 {
        return @intFromEnum(dt);
    }

    pub fn as_unix_timestamp_s(dt: DateTime) i64 {
        return @divTrunc(@intFromEnum(dt), std.time.ms_per_s);
    }

    pub fn lt(a: DateTime, b: DateTime) bool {
        return @intFromEnum(a) < @intFromEnum(b);
    }

    pub fn gt(a: DateTime, b: DateTime) bool {
        return @intFromEnum(a) > @intFromEnum(b);
    }
};

/// Time in nanoseconds since system startup.
pub const Absolute = enum(u64) {
    system_start = 0,

    _,

    /// Returns the time between `newer` and `older`.
    ///
    /// NOTE: Asserts that `newer` happened after `older`.
    pub fn time_since(newer: Absolute, older: Absolute) Duration {
        return Duration.from_ns(
            @intFromEnum(newer) - @intFromEnum(older),
        );
    }

    /// Returns the nanoseconds since system startup.
    pub fn ns_since_start(point: Absolute) u64 {
        return @intFromEnum(point);
    }

    /// Returns the microseconds since system startup.
    pub fn us_since_start(point: Absolute) u64 {
        return @intFromEnum(point) / std.time.us_per_ms;
    }

    /// Returns the milliseconds since system startup.
    pub fn ms_since_start(point: Absolute) u64 {
        return @intFromEnum(point) / std.time.ns_per_ms;
    }

    /// Increments the time point by `delta`.
    pub fn increment_by(abs: Absolute, delta: Duration) Absolute {
        return @enumFromInt(@intFromEnum(abs) + @intFromEnum(delta));
    }

    pub fn lt(a: Absolute, b: Absolute) bool {
        return @intFromEnum(a) < @intFromEnum(b);
    }

    pub fn gt(a: Absolute, b: Absolute) bool {
        return @intFromEnum(a) > @intFromEnum(b);
    }
};

/// A duration in nanoseconds.
pub const Duration = enum(u64) {
    _,

    /// Constructs a duration from a nanosecond time span.
    pub fn from_ns(ns: u64) Duration {
        return @enumFromInt(ns);
    }

    /// Constructs a duration from a microsecond time span.
    pub fn from_us(us: u64) Duration {
        return @enumFromInt(us * std.time.ns_per_us);
    }

    /// Constructs a duration from a millisecond time span.
    pub fn from_ms(ms: u64) Duration {
        return @enumFromInt(ms * std.time.ns_per_ms);
    }

    /// Returns the duration in nanoseconds.
    pub fn to_ns(dur: Duration) u64 {
        return @intFromEnum(dur);
    }

    /// Returns the duration in microseconds.
    pub fn to_us(dur: Duration) u64 {
        return @intFromEnum(dur) / std.time.ns_per_us;
    }

    /// Returns the duration in milliseconds.
    pub fn to_ms(dur: Duration) u64 {
        return @intFromEnum(dur) / std.time.ns_per_ms;
    }

    pub fn lt(a: Duration, b: Duration) bool {
        return @intFromEnum(a) < @intFromEnum(b);
    }

    pub fn gt(a: Duration, b: Duration) bool {
        return @intFromEnum(a) > @intFromEnum(b);
    }

    pub fn format(dur: Duration, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = options;
        const ns = dur.to_ns();

        const Scale = struct {
            unit: []const u8,
            divider: u64,
        };

        const scales = [_]Scale{
            .{ .unit = "week", .divider = std.time.ns_per_week },
            .{ .unit = "d", .divider = std.time.ns_per_day },
            .{ .unit = "m", .divider = std.time.ns_per_min },
            .{ .unit = "h", .divider = std.time.ns_per_hour },
            .{ .unit = "s", .divider = std.time.ns_per_s },
            .{ .unit = "ms", .divider = std.time.ns_per_ms },
            .{ .unit = "us", .divider = std.time.ns_per_us },
            .{ .unit = "ns", .divider = 1 },
        };

        const selected_scale: Scale = if (fmt.len > 0)
            comptime for (scales) |scale| {
                if (std.mem.eql(u8, scale.unit, fmt))
                    break scale;
            } else @compileError(fmt ++ " is not a valid duration unit!")
        else for (scales) |scale| {
            if (ns >= scale.divider)
                break scale;
        } else scales[0];

        const int_part = ns / selected_scale.divider;
        if (selected_scale.divider > 1) {
            const fract_part = ns % (1000 * selected_scale.divider);
            try writer.print("{d}.{d:0>3} {s}", .{ int_part, fract_part, selected_scale.unit });
        } else {
            try writer.print("{d} {s}", .{ int_part, selected_scale.unit });
        }
    }
};

/// Index into a color palette.
pub const ColorIndex = enum(u8) {
    _,

    pub fn get(val: u8) ColorIndex {
        return @as(ColorIndex, @enumFromInt(val));
    }

    pub fn index(c: ColorIndex) @typeInfo(ColorIndex).Enum.tag_type {
        return @intFromEnum(c);
    }

    pub fn shift(c: ColorIndex, offset: u8) ColorIndex {
        return get(index(c) +% offset);
    }
};

///////////////////////////////////////////////////////////
// Enumerations:

pub const PipeMode = enum(u8) {
    /// Completes immediatly even if no elements could be processed.
    nonblocking = 0,
    /// Returns when at least one element could be processed.
    at_least_one = 1,
    /// Returns only when all elements are processed.
    all = 2,
};

pub const NotificationSeverity = enum(u8) {
    /// Important information that require immediate action
    /// by the user.
    ///
    /// This should be handled with care and only for reall
    /// urgent situations like low battery power or
    /// unsufficient disk memory.
    attention = 0,

    /// This is a regular user notification, which should be used
    /// sparingly.
    ///
    /// Typical notifications of this kind are in the category of
    /// "download completed", "video fully rendered" or similar.
    information = 128,

    /// Silent notifications that might be informational, but do not
    /// require attention by the user at all.
    whisper = 255,
};

pub const IP_Type = enum(u8) { ipv4, ipv6 };

pub const Schedule_Result = enum(u8) {
    scheduled = 0,
};

pub const Await_Options = extern struct {
    wait: Wait,
    thread_affinity: Thread_Affinity,

    pub const Thread_Affinity = enum(u8) {
        /// Waits for ARCs scheduled from *any* thread in the current process.
        all_threads,

        /// Waits for ARCs scheduled from *this* thread.
        this_thread,
    };

    pub const Wait = enum(u8) {
        /// Don't wait for any additional calls to complete, just return
        /// whatever was completed in the meantime.
        dont_block = 0,

        /// Wait for at least a single call to complete operation.
        wait_one = 1,

        /// Wait until all scheduled operations have completed.
        ///
        /// This will only wait so long until either
        /// a) all scheduled ops are stored into the result array
        /// or
        /// b) the result array is full
        ///
        /// NOTE: If `thread_affinity` is `.all_threads`, other threads can still
        ///       schedule more operations and make this function block longer.
        wait_all = 2,

        /// Returns whether the operation is blocking or not.
        pub fn isBlocking(wait: Wait) bool {
            return switch (wait) {
                .dont_block => false,
                .wait_one => true,
                .wait_all => true,
            };
        }
    };
};

/// Index of the systems video outputs.
pub const VideoOutputID = enum(u8) {
    /// The primary video output
    primary = 0,
    _,
};

pub const FontType = enum(u32) {
    bitmap = 0,
    vector = 1,
    _,
};

pub const FramebufferType = enum(u8) {
    /// A pure in-memory frame buffer used for off-screen rendering.
    memory = 0,

    /// A video device backed frame buffer. Can be used to paint on a screen
    /// directly.
    video = 1,

    /// A frame buffer provided by a window. These frame buffers
    /// may hold additional semantic information.
    window = 2,

    /// A frame buffer provided by a user interface element. These frame buffers
    /// may hold additional semantic information.
    widget = 3,
};

pub const MessageBoxIcon = enum(u8) {
    information = 0,
    question = 1,
    warning = 2,
    @"error" = 3,
};

pub const MessageBoxResult = enum(u8) {
    ok = @bitOffsetOf(MessageBoxButtons, "ok"),
    cancel = @bitOffsetOf(MessageBoxButtons, "cancel"),
    yes = @bitOffsetOf(MessageBoxButtons, "yes"),
    no = @bitOffsetOf(MessageBoxButtons, "no"),
    abort = @bitOffsetOf(MessageBoxButtons, "abort"),
    retry = @bitOffsetOf(MessageBoxButtons, "retry"),
    @"continue" = @bitOffsetOf(MessageBoxButtons, "continue"),
    ignore = @bitOffsetOf(MessageBoxButtons, "ignore"),
};

pub const ExitCode = enum(u32) {
    success = @as(u32, 0),
    failure = @as(u32, 1),

    killed = ~@as(u32, 0),

    _,
};

pub const LogLevel = enum(u8) {
    critical = 0,
    err = 1,
    warn = 2,
    notice = 3,
    debug = 4,
};

pub const FileSystemId = enum(u32) {
    /// This is the file system which the os has bootet from.
    system = 0,

    /// the filesystem isn't valid.
    invalid = ~@as(u32, 0),

    /// All other ids are unique file systems.
    _,
};

pub const FileAttributes = packed struct(u16) {
    directory: bool,
    reserved: u15 = 0,
};

pub const FileAccess = enum(u8) {
    read_only = 0,
    write_only = 1,
    read_write = 2,
};

pub const FileMode = enum(u8) {
    open_existing = 0, // opens file when it exists on disk
    open_always = 1, // creates file when it does not exist, or opens the file without truncation.
    create_new = 2, // creates file when there is no file with that name
    create_always = 3, // creates file when it does not exist, or opens the file and truncates it to zero length
};

pub const KeyCode = enum(u16) {
    escape = 1,
    @"1",
    @"2",
    @"3",
    @"4",
    @"5",
    @"6",
    @"7",
    @"8",
    @"9",
    @"0",
    minus,
    equal,
    backspace,
    tab,
    q,
    w,
    e,
    r,
    t,
    y,
    u,
    i,
    o,
    p,
    left_brace,
    right_brace,
    @"return",
    ctrl_left,
    a,
    s,
    d,
    f,
    g,
    h,
    j,
    k,
    l,
    semicolon,
    apostrophe,
    grave,
    shift_left,
    backslash,
    z,
    x,
    c,
    v,
    b,
    n,
    m,
    comma,
    dot,
    slash,
    shift_right,
    kp_asterisk,
    alt,
    space,
    caps_lock,
    f1,
    f2,
    f3,
    f4,
    f5,
    f6,
    f7,
    f8,
    f9,
    f10,
    num_lock,
    scroll_lock,
    kp_7,
    kp_8,
    kp_9,
    kp_minus,
    kp_4,
    kp_5,
    kp_6,
    kp_plus,
    kp_1,
    kp_2,
    kp_3,
    kp_0,
    kp_dot,
    jp_zenkakuhankaku,
    @"102nd",
    f11,
    f12,
    jp_ro,
    jp_katakana,
    jp_hiragana,
    jp_henkan,
    jp_katakana_hiragana,
    jp_muhenkan,
    jp_kp_comma,
    kp_enter,
    ctrl_right,
    kp_slash,
    print,
    alt_graph,
    linefeed,
    home,
    up,
    page_up,
    left,
    right,
    end,
    down,
    page_down,
    insert,
    delete,
    meta,

    unknown = 0xFFFF,
};

pub const MouseButton = enum(u8) {
    none = 0,
    left = 1,
    right = 2,
    middle = 3,
    nav_previous = 4,
    nav_next = 5,
    wheel_down = 6,
    wheel_up = 7,
};

///////////////////////////////////////////////////////////
// Compound types:

pub const SpawnProcessArg = struct {
    /// Creates a new SpawnProcessArg that is a string.
    pub fn string(text: []const u8) SpawnProcessArg {
        return .{ .type = .string, .value = .{ .text = String.new(text) } };
    }

    /// Creates a new SpawnProcessArg that refers to a resource.
    pub fn resource(handle: SystemResource) SpawnProcessArg {
        return .{ .type = .resource, .value = .{ .resource = handle } };
    }

    type: Type,
    value: extern union {
        text: String,
        resource: SystemResource,
    },

    pub const Type = enum(u8) {
        string = 0,
        resource = 1,
    };

    pub const String = extern struct {
        ptr: [*]const u8,
        len: usize,

        pub fn new(_slice: []const u8) String {
            return .{ .ptr = _slice.ptr, .len = _slice.len };
        }

        pub fn slice(str: String) []const u8 {
            return str.ptr[0..str.len];
        }
    };
};

pub const WindowFlags = packed struct(u32) {
    popup: bool,
    resizable: bool,
    padding: u30 = 0,
};

pub const CreateWindowFlags = packed struct(u32) {
    popup: bool = false,
    padding: u31 = 0,
};

pub const WidgetDescriptor = extern struct {
    uuid: UUID,

    /// Number of bytes allocated in a Widget for this widget type.
    /// See `get_widget_data` function for further information.
    data_size: usize,

    flags: Flags,

    // TODO: Fill this out

    // Event Handlers:

    handle_event: *const fn (Widget, *const WidgetEvent) callconv(.C) void,

    pub const Flags = packed struct(u32) {
        /// If `true`, the user can focus this widget with the mouse or keyboard.
        focusable: bool,

        /// If `true`, the user is able to open a context menu on this.
        context_menu: bool,

        /// If `true`, this widget is able to receive events with the mouse.
        /// If `false`, the widget is ignored in the position-to-widget resolution.
        hit_test_visible: bool,

        /// If `true`, the user is able to potentially drop data via Drag&Drop
        /// on this widget.
        allow_drop: bool,

        /// If `true`, the user can copy/cut/paste data from/into this widget.
        clipboard_sensitive: bool,

        _padding: u27 = 0,
    };
};

pub const WidgetControlMessage = extern struct {
    event_type: WidgetEvent.Type,

    /// The widget-specific type of the control message.
    /// Could be something like `get_property`, `set_property`, `set_text`, ...
    type: u32,

    /// Generic parameters that can be passed to the widget.
    params: [4]usize,
};

pub const WidgetNotifyEvent = extern struct {
    event_type: WindowEvent.Type,

    widget: Widget,

    /// The widget-specific type of event.
    /// Could be something like `text_changed`, `clicked`, `checked_changed`, ...
    type: u32,

    /// Generic data associated with the event.
    data: [4]usize,
};

pub const MessageBoxButtons = packed struct(u8) {
    pub const ok: MessageBoxButtons = .{ .ok = true };
    pub const ok_cancel: MessageBoxButtons = .{ .ok = true, .cancel = true };
    pub const yes_no: MessageBoxButtons = .{ .yes = true, .no = true };
    pub const yes_no_cancel: MessageBoxButtons = .{ .yes = true, .no = true, .cancel = true };
    pub const retry_cancel: MessageBoxButtons = .{ .retry = true, .cancel = true };
    pub const abort_retry_ignore: MessageBoxButtons = .{ .abort = true, .retry = true, .ignore = true };

    ok: bool = false,
    cancel: bool = false,
    yes: bool = false,
    no: bool = false,
    abort: bool = false,
    retry: bool = false,
    @"continue": bool = false,
    ignore: bool = false,

    pub fn format(buttons: MessageBoxButtons, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;
        const max_length = comptime "ok,cancel,yes,no,abort,retry,continue,ignore".len;

        var buffer: [max_length]u8 = undefined;
        var stream = std.io.fixedBufferStream(&buffer);

        if (buttons.ok) {
            if (stream.pos > 0) _ = stream.write(",") catch unreachable;
            stream.writer().writeAll("ok") catch unreachable;
        }
        if (buttons.cancel) {
            if (stream.pos > 0) _ = stream.write(",") catch unreachable;
            stream.writer().writeAll("cancel") catch unreachable;
        }
        if (buttons.yes) {
            if (stream.pos > 0) _ = stream.write(",") catch unreachable;
            stream.writer().writeAll("yes") catch unreachable;
        }
        if (buttons.no) {
            if (stream.pos > 0) _ = stream.write(",") catch unreachable;
            stream.writer().writeAll("no") catch unreachable;
        }
        if (buttons.abort) {
            if (stream.pos > 0) _ = stream.write(",") catch unreachable;
            stream.writer().writeAll("abort") catch unreachable;
        }
        if (buttons.retry) {
            if (stream.pos > 0) _ = stream.write(",") catch unreachable;
            stream.writer().writeAll("retry") catch unreachable;
        }
        if (buttons.@"continue") {
            if (stream.pos > 0) _ = stream.write(",") catch unreachable;
            stream.writer().writeAll("continue") catch unreachable;
        }
        if (buttons.ignore) {
            if (stream.pos > 0) _ = stream.write(",") catch unreachable;
            stream.writer().writeAll("ignore") catch unreachable;
        }

        if (stream.pos > 0) {
            try writer.writeAll(stream.getWritten());
        } else {
            try writer.writeAll("none");
        }
    }
};

pub const DesktopDescriptor = extern struct {
    /// Number of bytes allocated in a Window for this desktop.
    /// See `get_desktop_data` function for further information.
    window_data_size: usize,

    /// A function pointer to the event handler of a desktop.
    /// The desktop will receive events via this function.
    handle_event: *const fn (Desktop, *const DesktopEvent) callconv(.C) void,
};

pub const DesktopEvent = extern union {
    event_type: Type,

    create_window: DesktopWindowEvent,
    destroy_window: DesktopWindowEvent,
    invalidate_window: DesktopWindowInvalidateEvent,

    show_notification: DesktopNotificationEvent,
    show_message_box: MessageBoxEvent,

    pub const Type = enum(u16) {
        // lifecycle management:

        /// A window was created on this desktop.
        create_window = 0,

        /// A window was destroyed on this desktop.
        destroy_window = 1,

        /// A window has been invalidated and must be drawn again.
        invalidate_window = 2,

        // user interaction:

        /// `send_notification` was called and the desktop user should display
        /// a notification.
        show_notification = 3,

        /// `send_notification` was called and the desktop user should display
        /// a notification.
        show_message_box = 4,

        _,
    };

    comptime {
        validate_event_type(@This());
    }
};

pub const DesktopWindowEvent = extern struct {
    event_type: DesktopEvent.Type,
    window: Window,
};

pub const DesktopWindowInvalidateEvent = extern struct {
    event_type: DesktopEvent.Type,
    window: Window,
    area: Rectangle,
};

pub const DesktopNotificationEvent = extern struct {
    event_type: DesktopEvent.Type,

    /// The text of the notification.
    message_ptr: [*]const u8,

    /// Length of `message_ptr`.
    message_len: usize,

    /// The severity/importance of the notification.
    severity: NotificationSeverity,

    pub fn message(ev: DesktopNotificationEvent) []const u8 {
        return ev.message_ptr[0..ev.message_len];
    }
};

pub const MessageBoxEvent = extern struct {
    event_type: DesktopEvent.Type,

    /// The desktop-specific request id that must be passed into
    /// `notify_message_box` to finish the message box request.
    request_id: RequestID,

    /// Pointer to the content of the message box.
    message_ptr: [*]const u8,

    /// length of `message_ptr`.
    message_len: usize,

    /// Pointer to the caption of the message box.
    caption_ptr: [*]const u8,

    /// length of `caption_ptr`.
    caption_len: usize,

    /// Which buttons are presented to the user?
    buttons: MessageBoxButtons,

    /// Which icon is shown?
    icon: MessageBoxIcon,

    pub const RequestID = enum(u16) { _ };

    pub fn caption(ev: MessageBoxEvent) []const u8 {
        return ev.caption_ptr[0..ev.caption_len];
    }

    pub fn message(ev: MessageBoxEvent) []const u8 {
        return ev.message_ptr[0..ev.message_len];
    }
};

/// A 16 bpp color value using RGB565 encoding.
pub const Color = packed struct(u16) {
    r: u5,
    g: u6,
    b: u5,

    pub fn toU16(c: Color) u16 {
        return @as(u16, @bitCast(c));
    }

    pub fn fromU16(u: u16) Color {
        return @as(Color, @bitCast(u));
    }

    pub fn fromRgb888(r: u8, g: u8, b: u8) Color {
        return Color{
            .r = @as(u5, @truncate(r >> 3)),
            .g = @as(u6, @truncate(g >> 2)),
            .b = @as(u5, @truncate(b >> 3)),
        };
    }

    pub fn toRgb32(color: Color) u32 {
        const exp = color.toRgb888();
        return @as(u32, exp.r) << 0 |
            @as(u32, exp.g) << 8 |
            @as(u32, exp.b) << 16;
    }

    pub fn toRgb888(color: Color) RGB888 {
        const src_r: u8 = color.r;
        const src_g: u8 = color.g;
        const src_b: u8 = color.b;

        // expand bits to form a linear range between 0â€¦255
        return .{
            .r = (src_r << 3) | (src_r >> 2),
            .g = (src_g << 2) | (src_g >> 4),
            .b = (src_b << 3) | (src_b >> 2),
        };
    }

    pub const RGB888 = extern struct {
        r: u8,
        g: u8,
        b: u8,
    };
};

pub const InputEvent = extern union {
    event_type: Type,
    mouse: MouseEvent,
    keyboard: KeyboardEvent,

    pub const Type = enum(u16) {
        key_press = 0,
        key_release = 1,

        mouse_rel_motion = 2,
        mouse_abs_motion = 3,
        mouse_button_press = 4,
        mouse_button_release = 5,
    };

    comptime {
        validate_event_type(@This());
    }
};

pub const WidgetEvent = extern union {
    event_type: Type,

    mouse: MouseEvent,
    keyboard: KeyboardEvent,
    control: WidgetControlMessage,

    // TODO: Add event data

    pub const Type = enum(u16) {
        // lifecycle:

        /// The widget was created and attached to a window.
        create = 0,

        /// The widget is in the process of being destroyed.
        /// After this event, the handle will be invalid.
        destroy = 1,

        /// The creator of the widget wants to do something widget-specific.
        control = 2,

        // basic input:

        /// The user clicked on the widget with the primary mouse button
        /// or pressed the return or space bar button on the keyboard.
        click = 3,

        // keyboard input:

        /// A key was pressed on the keyboard.
        key_press = 4,

        /// A key was released on the keyboard.
        key_release = 5,

        // mouse specific extras:

        /// The mouse was moved inside the rectangle of the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_enter = 6,

        /// The mouse was moved outside the rectangle of the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_leave = 7,

        /// The mouse stopped for some time over the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_hover = 8,

        /// A mouse button was pressed over the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_button_press = 9,

        /// A mouse button was released over the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_button_release = 10,

        /// The mouse was moved over the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        mouse_motion = 11,

        /// A vertical or horizontal scroll wheel was scrolled over the widget.
        ///
        /// NOTE: This event can only happen when `hit_test_visible` was set
        /// in the widget creation flags.
        scroll = 12,

        // drag&drop operations:

        /// The user dragged a payload into the rectangle of this widget.
        ///
        /// NOTE: This event can only happen when `allow_drop` was set in the
        /// widget creation flags.
        drag_enter = 13,

        /// The user dragged a payload out of the rectangle of this widget.
        ///
        /// NOTE: This event can only happen when `allow_drop` was set in the
        /// widget type creation flags.
        drag_leave = 14,

        /// The user dragged a payload over the rectangle of this widget.
        ///
        /// NOTE: This event can only happen when `allow_drop` was set in the
        /// widget type creation flags.
        drag_over = 15,

        /// The user dropped a payload into this widget.
        ///
        /// NOTE: This event can only happen when `allow_drop` was set in the
        /// widget type creation flags.
        drag_drop = 16,

        // clipboard operations:

        /// The user requested a clipboard copy operation, usually by pressing 'Ctrl-C'.
        ///
        /// NOTE: This event can only happen when `clipboard_sensitive` was set in
        /// the widget type creation flags.
        clipboard_copy = 17,

        /// The user requested a clipboard paste operation, usually by pressing 'Ctrl-V'.
        ///
        /// NOTE: This event can only happen when `clipboard_sensitive` was set in
        /// the widget type creation flags.
        clipboard_paste = 18,

        /// The user requested a clipboard cut operation, usually by pressing 'Ctrl-X'.
        ///
        /// NOTE: This event can only happen when `clipboard_sensitive` was set in
        /// the widget type creation flags.
        clipboard_cut = 19,

        // widget specific:

        /// The widget was resized with a call to `place_widget`.
        ///
        /// NOTE: This event will not fire if the widget was only moved.
        resized = 21,

        /// The widget should draw itself.
        paint = 20,

        /// User pressed the "context menu" button or did a
        /// secondary mouse button click on the  widget.
        context_menu_request = 22,

        /// The widget received focus via mouse or keyboard.
        focus_enter = 23,

        /// The widget lost focus after receiving it.
        focus_leave = 24,

        _,
    };

    comptime {
        validate_event_type(@This());
    }
};

pub const WindowEvent = extern union {
    event_type: Type,

    mouse: MouseEvent,
    keyboard: KeyboardEvent,
    widget_notify: WidgetNotifyEvent,

    pub const Type = enum(u16) {
        widget_notify = 0,

        key_press = 1,
        key_release = 2,

        mouse_enter = 3,
        mouse_leave = 4,
        mouse_motion = 7,
        mouse_button_press = 6,
        mouse_button_release = 5,

        /// The user requested the window to be closed.
        window_close = 8,

        /// The window was minimized and is not visible anymore.
        window_minimize = 9,

        /// The window was restored from minimized state.
        window_restore = 10,

        /// The window is currently moving on the screen. Query `window.bounds` to get the new position.
        window_moving = 11,

        /// The window was moved on the screen. Query `window.bounds` to get the new position.
        window_moved = 12,

        /// The window size is currently changing. Query `window.bounds` to get the new size.
        window_resizing = 13,

        /// The window size changed. Query `window.bounds` to get the new size.
        window_resized = 14,
    };

    comptime {
        validate_event_type(@This());
    }
};

fn validate_event_type(comptime Event: type) void {
    const union_fields = @typeInfo(Event).Union.fields;

    // first union field must define our event type:
    std.debug.assert(union_fields[0].type == Event.Type);

    var requires_shared_event_type = false;

    // check that all other fields are extern structs that share
    // the first field with this union:
    for (union_fields[1..]) |fld| {
        const event_type = @typeInfo(fld.type).Struct;

        const first_field = event_type.fields[0];

        const Msg = [1][]const u8;
        var problems: []const []const u8 = &.{};

        if (event_type.layout != .@"extern") {
            problems = problems ++ &.{"layout not extern"};
        }
        if (first_field.type != Event.Type and first_field.type != SharedEventType) {
            problems = problems ++ Msg{"first field must be either Event.Type or SharedEventType"};
        }
        if (!std.mem.eql(u8, first_field.name, union_fields[0].name)) {
            problems = problems ++ Msg{std.fmt.comptimePrint("first field must be named {}", .{std.zig.fmtId(first_field.name)})};
        }
        if (@offsetOf(fld.type, union_fields[0].name) != 0) {
            problems = problems ++ Msg{std.fmt.comptimePrint("{} must have offset 0", .{std.zig.fmtId(union_fields[0].name)})};
        }

        if (problems.len > 0) {
            var msg: []const u8 = "failed to validate " ++ @typeName(Event) ++ ":";
            for (problems) |problem| {
                msg = msg ++ "\n" ++ problem;
            }
            @compileError(msg);
        }

        if (first_field.type == SharedEventType) {
            requires_shared_event_type = true;
        }
    }

    if (requires_shared_event_type) {
        const in_shared_type = for (@typeInfo(SharedEventType).Union.fields) |fld| {
            if (fld.type == Event.Type)
                break true;
        } else false;
        if (!in_shared_type)
            @compileError(@typeName(Event.Type) ++ " is not contained in SharedEventType!");
    }
}

/// Event structures shared between different event groups
pub const SharedEventType = extern union {
    input: InputEvent.Type,
    widget: WidgetEvent.Type,
    window: WindowEvent.Type,
};

pub const MouseEvent = extern struct {
    event_type: SharedEventType, // MUST BE FIRST!

    x: i16,
    y: i16,
    dx: i16,
    dy: i16,
    button: MouseButton,
};

pub const KeyboardEvent = extern struct {
    event_type: SharedEventType, // MUST BE FIRST!

    /// The raw scancode for the key. Meaning depends on the layout,
    /// represents kinda the physical position on the keyboard.
    scancode: u32,

    /// The virtual key, independent of layout. Represents the logical
    /// function of the key.
    key: KeyCode,

    /// If set, the pressed key combination has a mapping that produces
    /// text input. UTF-8 encoded.
    text: ?[*:0]const u8,

    /// The key in this event was pressed or released
    pressed: bool,

    /// The modifier keys currently active
    modifiers: KeyboardModifiers,
};

pub const KeyboardModifiers = packed struct(u16) {
    shift: bool,
    alt: bool,
    ctrl: bool,
    shift_left: bool,
    shift_right: bool,
    ctrl_left: bool,
    ctrl_right: bool,
    alt_graph: bool,
    padding: u8 = 0,
};

pub const Point = extern struct {
    pub const zero = new(0, 0);

    x: i16,
    y: i16,

    pub fn new(x: i16, y: i16) Point {
        return Point{ .x = x, .y = y };
    }

    pub fn eql(a: Point, b: Point) bool {
        return (a.x == b.x) and (a.y == b.y);
    }

    pub fn manhattenDistance(a: Point, b: Point) u16 {
        return @abs(a.x - b.x) + @abs(a.y - b.y);
    }

    pub fn format(point: Point, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;
        try writer.print("Point({},{})", .{
            point.x, point.y,
        });
    }
};

pub const Size = extern struct {
    pub const empty = new(0, 0);
    pub const max = new(std.math.maxInt(u16), std.math.maxInt(u16));

    width: u16,
    height: u16,

    pub fn new(w: u16, h: u16) Size {
        return Size{ .width = w, .height = h };
    }

    pub fn eql(a: Size, b: Size) bool {
        return (a.width == b.width) and (a.height == b.height);
    }

    pub fn format(size: Size, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;
        try writer.print("Size({}x{})", .{
            size.width,
            size.height,
        });
    }
};

pub const Rectangle = extern struct {
    x: i16,
    y: i16,
    width: u16,
    height: u16,

    pub fn new(pos: Point, siz: Size) Rectangle {
        return Rectangle{
            .x = pos.x,
            .y = pos.y,
            .width = siz.width,
            .height = siz.height,
        };
    }

    pub fn position(rect: Rectangle) Point {
        return Point{ .x = rect.x, .y = rect.y };
    }

    pub fn size(rect: Rectangle) Size {
        return Size{ .width = rect.width, .height = rect.height };
    }

    pub fn empty(rect: Rectangle) bool {
        return (rect.width == 0) and (rect.height == 0);
    }

    pub fn contains(rect: Rectangle, pt: Point) bool {
        return (pt.x >= rect.x) and
            (pt.x < rect.x + @as(u15, @intCast(rect.width))) and
            (pt.y >= rect.y) and
            (pt.y < rect.y + @as(u15, @intCast(rect.height)));
    }

    pub fn containsRectangle(boundary: Rectangle, region: Rectangle) bool {
        return boundary.contains(region.position()) and
            boundary.contains(Point.new(region.x + @as(u15, @intCast(region.width)) - 1, region.y + @as(u15, @intCast(region.height)) - 1));
    }

    /// Returns true if `a` and `b` overlap.
    pub fn intersects(a: Rectangle, b: Rectangle) bool {
        return a.x + @as(u15, @intCast(a.width)) >= b.x and
            a.y + @as(u15, @intCast(a.height)) >= b.y and
            a.x <= b.x + @as(u15, @intCast(b.width)) and
            a.y <= b.y + @as(u15, @intCast(b.height));
    }

    /// Returns the overlapping region of `a` and `b`.
    pub fn overlap(a: Rectangle, b: Rectangle) Rectangle {
        const _left = @max(a.left(), b.left());
        const _right = @min(a.right(), b.right());
        const _top = @max(a.top(), b.top());
        const _bottom = @min(a.bottom(), b.bottom());

        return .{
            .x = _left,
            .y = _top,
            .width = @intCast(_right -| _left),
            .height = @intCast(_bottom -| _top),
        };
    }

    pub fn eql(a: Rectangle, b: Rectangle) bool {
        return a.size().eql(b.size()) and a.position().eql(b.position());
    }

    pub fn top(rect: Rectangle) i16 {
        return rect.y;
    }
    pub fn bottom(rect: Rectangle) i16 {
        return rect.y + @as(u15, @intCast(rect.height));
    }
    pub fn left(rect: Rectangle) i16 {
        return rect.x;
    }
    pub fn right(rect: Rectangle) i16 {
        return rect.x +| @as(u15, @intCast(rect.width));
    }

    pub fn shrink(rect: Rectangle, amount: u15) Rectangle {
        var copy = rect;
        copy.x +|= amount;
        copy.y +|= amount;
        copy.width -|= 2 * amount;
        copy.height -|= 2 * amount;
        return copy;
    }

    pub fn grow(rect: Rectangle, amount: u15) Rectangle {
        var copy = rect;
        copy.x -|= amount;
        copy.y -|= amount;
        copy.width +|= 2 * amount;
        copy.height +|= 2 * amount;
        return copy;
    }

    pub fn format(rect: Rectangle, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;
        try writer.print("Rectangle({},{},{}x{})", .{
            rect.x,
            rect.y,
            rect.width,
            rect.height,
        });
    }

    pub fn corner(rect: Rectangle, corner_id: Corner) Point {
        const edge: u2 = @intFromEnum(corner_id);

        var x: i16 = rect.x;
        var y: i16 = rect.y;

        x += @intCast(@intFromBool((edge & 1) != 0) * rect.width);
        y += @intCast(@intFromBool((edge & 2) != 0) * rect.height);

        return Point.new(x, y);
    }

    pub const Corner = enum(u2) {
        // Encodes X/Y position in bits:
        top_left = 0b00,
        top_right = 0b01,
        bottom_left = 0b10,
        bottom_right = 0b11,
    };
};

pub const VideoMemory = extern struct {
    /// Pointer to the first pixel of the first scanline.
    ///
    /// Each scanline is `.stride` elements separated from
    /// each other and contains `width` valid elements.
    ///
    /// There are `height` total scanlines available.
    base: [*]align(4) ColorIndex,

    /// Length of a scanline.
    stride: usize,

    /// Number of valid elements in a scanline
    width: u16,

    /// Number of valid scanlines.
    height: u16,
};

pub const FileSystemInfo = extern struct {
    id: FileSystemId, // system-unique id of this file system
    flags: Flags, // binary infos about the file system
    name: [max_fs_name_len]u8, // user addressable file system identifier ("USB0", ...)
    filesystem: [max_fs_type_len]u8, // string identifier of a file system driver ("FAT32", ...)

    pub const Flags = packed struct(u16) {
        system: bool, // is the system boot disk
        removable: bool, // the file system can be removed by the user
        read_only: bool, // the file system is mounted as read-only
        reserved: u13 = 0,
    };

    pub fn getName(fi: *const FileInfo) []const u8 {
        return std.mem.sliceTo(&fi.name, 0);
    }

    pub fn getFileSystem(fi: *const FileInfo) []const u8 {
        return std.mem.sliceTo(&fi.filesystem, 0);
    }
};

pub const FileInfo = extern struct {
    name: [max_file_name_len]u8,
    size: u64,
    attributes: FileAttributes,
    creation_date: DateTime,
    modified_date: DateTime,

    pub fn getName(fi: *const FileInfo) []const u8 {
        return std.mem.sliceTo(&fi.name, 0);
    }
};

pub const IP = extern struct {
    type: IP_Type,
    addr: extern union {
        v4: IPv4,
        v6: IPv6,
    },

    pub fn ipv4(addr: [4]u8) IP {
        return IP{ .type = .ipv4, .addr = .{ .v4 = .{ .addr = addr } } };
    }

    pub fn ipv6(addr: [16]u8, zone: u8) IP {
        return IP{ .type = .ipv6, .addr = .{ .v6 = .{ .addr = addr, .zone = zone } } };
    }

    pub fn format(ip: IP, comptime fmt: []const u8, opt: std.fmt.FormatOptions, writer: anytype) !void {
        switch (ip.type) {
            .ipv4 => try ip.addr.v4.format(fmt, opt, writer),
            .ipv6 => try ip.addr.v6.format(fmt, opt, writer),
        }
    }
};

pub const IPv4 = extern struct {
    addr: [4]u8 align(4),

    pub fn format(ip: IPv4, comptime fmt: []const u8, opt: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = opt;
        try writer.print("{}.{}.{}.{}", .{
            ip.addr[0],
            ip.addr[1],
            ip.addr[2],
            ip.addr[3],
        });
    }
};

pub const IPv6 = extern struct {
    addr: [16]u8 align(4),
    zone: u8,

    pub fn format(ip: IPv6, comptime fmt: []const u8, opt: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = opt;
        try writer.print("[{X:0>2}{X:0>2}:{X:0>2}{X:0>2}:{X:0>2}{X:0>2}:{X:0>2}{X:0>2}:{X:0>2}{X:0>2}:{X:0>2}{X:0>2}:{X:0>2}{X:0>2}:{X:0>2}{X:0>2}/{}]", .{
            ip.addr[0],
            ip.addr[1],
            ip.addr[2],
            ip.addr[3],
            ip.addr[4],
            ip.addr[5],
            ip.addr[6],
            ip.addr[7],
            ip.addr[8],
            ip.addr[9],
            ip.addr[10],
            ip.addr[11],
            ip.addr[12],
            ip.addr[13],
            ip.addr[14],
            ip.addr[15],
            ip.zone,
        });
    }
};

pub const EndPoint = extern struct {
    ip: IP,
    port: u16,

    pub fn new(ip: IP, port: u16) EndPoint {
        return EndPoint{ .ip = ip, .port = port };
    }
};

///////////////////////////////////////////////////////////
// Callback types:

///////////////////////////////////////////////////////////
// Legacy:

// pub const NetworkStatus = enum(u8) {
//     disconnected = 0, // no cable is plugged in
//     mac_available = 1, // cable is plugged in and connected, no DHCP or static IP performed yet
//     ip_available = 2, // interface got at least one IP assigned
//     gateway_available = 3, // the gateway, if any, is reachable
// };

// pub const Ping = extern struct {
//     destination: IP, // who to ping
//     ttl: u16, // hops
//     timeout: u16, // ms, a minute timeout for ping is enough. if you have a higher ping, you have other problems
//     response: u16 = undefined, // response time in ms
// };
