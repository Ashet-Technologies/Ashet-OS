const std = @import("std");
const abi_parser = @import("abi-parser");

const model = abi_parser.model;

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    const allocator = arena.allocator();

    const argv = try std.process.argsAlloc(allocator);

    if (argv.len != 3)
        @panic("<exe> <input> <output>");

    const json_txt = try std.fs.cwd().readFileAlloc(allocator, argv[1], 1 << 30);

    const schema = try model.from_json_str(allocator, json_txt);

    var output = try std.fs.cwd().atomicFile(argv[2], .{});
    defer output.deinit();

    const document = schema.value;

    try render_docs(output.file.writer(), allocator, document);

    try output.finish();
}

fn render_header(writer: std.fs.File.Writer) !void {
    try writer.writeAll(
        \\//!
        \\//! THIS CODE WAS AUTOGENERATED!
        \\//!
        \\
        \\
        \\
    );
}

pub fn render_definition(writer: std.fs.File.Writer, allocator: std.mem.Allocator, schema: model.Document) !void {
    try render_header(writer);
    _ = allocator;
    _ = schema;

    try writer.writeAll(
        \\
        \\//
        \\// The code beyond this is copied verbatim from the input file!
        \\//
        \\
        \\
    );
}

pub fn render_userland(writer: std.fs.File.Writer, allocator: std.mem.Allocator, schema: model.Document) !void {
    try render_header(writer);
    _ = allocator;
    _ = schema;
}

pub fn render_kernel(writer: std.fs.File.Writer, allocator: std.mem.Allocator, schema: model.Document) !void {
    try render_header(writer);
    _ = allocator;
    _ = schema;
}

pub fn render_stubs(writer: std.fs.File.Writer, allocator: std.mem.Allocator, schema: model.Document) !void {
    _ = writer;
    _ = allocator;
    _ = schema;
}

pub fn render_docs(writer: std.fs.File.Writer, allocator: std.mem.Allocator, schema: model.Document) !void {
    try writer.writeAll(
        \\<!doctype html>
        \\<html lang="en">
        \\
        \\<head>
        \\    <meta charset="UTF-8">
        \\    <title>Ashet OS System Calls</title>
        \\    <link rel="stylesheet" href="style.css">
        \\</head>
        \\
        \\<body>
        \\    
        \\    <nav>
        \\        <svg id="logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22">
        \\            <title>alert</title>
        \\            <path d="M20 20H2V19H1V15H2V13H3V11H4V9H5V7H6V5H7V3H8V2H14V3H15V5H16V7H17V9H18V11H19V13H20V15H21V19H20V20M9 6H8V8H7V10H6V12H5V14H4V16H3V18H19V16H18V14H17V12H16V10H15V8H14V6H13V4H9V6M10 7H12V13H10V7M10 14H12V16H10V14Z" />
        \\        </svg>
        \\        <div class="navigation">
        \\            <div id="searchbox">
        \\                <input id="search" type="search" placeholder="Search...">
        \\            </div>
        \\            <ul id="breadcrumbs">
        \\                <a href="#">ashet</a>
        \\                <a href="#ashet.process">process</a>
        \\                <a href="#ashet.process.thread">thread</a>
        \\                <a href="#ashet.process.thread.ThreadFunction" data-active>ThreadFunction</a>
        \\            </ul>
        \\        </div>
        \\    </nav>
        \\    <main>
        \\
    );

    var renderer: HtmlRenderer = .{
        .allocator = allocator,
        .stack = .init(allocator),
        .writer = writer,
        .schema = &schema,
    };
    defer renderer.stack.deinit();

    try renderer.render_declaration("ashet", .{
        .docs = &.{},
        .children = schema.root,
        .full_qualified_name = &.{"ashet"},
        .data = .namespace,
    });

    try writer.writeAll(
        \\    </main>
        \\
        \\</body>
        \\
        \\</html>
    );
}

const HtmlRenderer = struct {
    writer: std.fs.File.Writer,
    stack: std.ArrayList([]const u8),
    allocator: std.mem.Allocator,
    schema: *const model.Document,

    pub fn render_declaration(html: *HtmlRenderer, scope_name: []const u8, decl: model.Declaration) !void {
        try html.stack.append(scope_name);
        defer std.debug.assert(std.mem.eql(u8, html.stack.pop().?, scope_name));

        for (decl.children) |child| {
            try html.render_declaration(child.full_qualified_name[child.full_qualified_name.len - 1], child);
        }

        try html.writer.print(
            \\        <section id="{[0]}">
            \\            <h1>{[1]s}: {[0]}</h1>
            \\
        ,
            .{
                fmt_fqn(html.stack.items),
                @tagName(decl.data),
            },
        );

        if (decl.docs.len > 0) {
            try html.writer.print("<h2>Documentation</h2>\n", .{});
            try html.writer.print("{}\n", .{fmt_docs(decl.docs)});
        }

        switch (decl.data) {
            .namespace => {},
            .@"struct" => |index| {
                const item = html.schema.structs[@intFromEnum(index)];

                try html.writer.print("<h2>Fields</h2>\n", .{});

                try html.begin_dl();
                for (item.fields) |field| {
                    try html.writer.writeAll("<div>\n");

                    try html.writer.print("<dt><code>{s}: {}", .{
                        field.name,
                        html.fmt_type(field.type),
                    });

                    if (field.default) |default| {
                        try html.writer.print(" = {}", .{html.fmt_value(default)});
                    }

                    try html.writer.writeAll("</code></dt>");

                    if (field.docs.len > 0) {
                        try html.writer.print("<dd>{}</dd>\n", .{fmt_docs(field.docs)});
                    }

                    try html.writer.writeAll("</div>\n");
                }
                try html.end_dl();
            },
            .@"union" => |index| {
                const item = html.schema.unions[@intFromEnum(index)];

                try html.writer.print("<h2>Alternatives</h2>\n", .{});

                try html.begin_dl();
                for (item.fields) |field| {
                    try html.dl_item(
                        "{s}: {}",
                        "{}",
                        .{
                            field.name,
                            html.fmt_type(field.type),
                            fmt_docs(field.docs),
                        },
                    );
                }
                try html.end_dl();
            },
            .@"enum" => |index| {
                const enumeration = html.schema.enums[@intFromEnum(index)];

                // TODO: enumeration.backing_type

                try html.writer.print("<h2>Items</h2>\n", .{});

                try html.begin_dl();
                for (enumeration.items) |item| {
                    try html.dl_item(
                        "{s} = {}",
                        "{}",
                        .{
                            item.name,
                            item.value,
                            fmt_docs(item.docs),
                        },
                    );
                }

                switch (enumeration.kind) {
                    .open => try html.dl_item(
                        "...",
                        "<p>This enumeration is non-exhaustive and may assume all values a {s} can represent.</p>",
                        .{@tagName(enumeration.backing_type)},
                    ),
                    .closed => {},
                }

                try html.end_dl();
            },
            .bitstruct => |index| {
                const item = html.schema.bitstructs[@intFromEnum(index)];
                try html.writer.print("<h2>Fields</h2>\n", .{});

                try html.begin_dl();
                for (item.fields) |field| {
                    try html.writer.writeAll("<div>\n");

                    try html.writer.print("<dt><code>{s}: {}", .{
                        field.name orelse "<i>reserved</i>",
                        html.fmt_type(field.type),
                    });

                    if (field.default) |default| {
                        try html.writer.print(" = {}", .{html.fmt_value(default)});
                    }

                    try html.writer.writeAll("</code></dt>");

                    if (field.docs.len > 0) {
                        try html.writer.print("<dd>{}</dd>\n", .{fmt_docs(field.docs)});
                    }

                    try html.writer.writeAll("</div>\n");
                }
                try html.end_dl();
            },
            .syscall => |index| {
                const item = html.schema.syscalls[@intFromEnum(index)];

                if (item.inputs.len > 0) {
                    try html.writer.print("<h2>Inputs</h2>\n", .{});

                    try html.begin_dl();
                    for (item.inputs) |param| {
                        // TODO: Handle "param.default"
                        try html.dl_item(
                            "{}: {}",
                            "{}",
                            .{
                                std.zig.fmtId(param.name),
                                html.fmt_type(param.type),
                                fmt_docs(param.docs),
                            },
                        );
                    }
                    try html.end_dl();
                }

                if (item.outputs.len > 0) {
                    try html.writer.print("<h2>Outputs</h2>\n", .{});

                    try html.begin_dl();
                    for (item.outputs) |param| {
                        // TODO: Handle "param.default"
                        try html.dl_item(
                            "{}: {}",
                            "{}",
                            .{
                                std.zig.fmtId(param.name),
                                html.fmt_type(param.type),
                                fmt_docs(param.docs),
                            },
                        );
                    }
                    try html.end_dl();
                }

                if (item.errors.len > 0) {
                    try html.writer.print("<h2>Errors</h2>\n", .{});

                    try html.begin_dl();
                    for (item.errors) |err| {
                        try html.dl_item(
                            "{}",
                            "{}",
                            .{
                                std.zig.fmtId(err.name),
                                fmt_docs(err.docs),
                            },
                        );
                    }
                    try html.end_dl();
                }
            },
            .async_call => |index| {
                const item = html.schema.async_calls[@intFromEnum(index)];

                if (item.inputs.len > 0) {
                    try html.writer.print("<h2>Inputs</h2>\n", .{});

                    try html.begin_dl();
                    for (item.inputs) |param| {
                        // TODO: Handle "param.default"
                        try html.dl_item(
                            "{}: {}",
                            "{}",
                            .{
                                std.zig.fmtId(param.name),
                                html.fmt_type(param.type),
                                fmt_docs(param.docs),
                            },
                        );
                    }
                    try html.end_dl();
                }

                if (item.outputs.len > 0) {
                    try html.writer.print("<h2>Outputs</h2>\n", .{});

                    try html.begin_dl();
                    for (item.outputs) |param| {
                        // TODO: Handle "param.default"
                        try html.dl_item(
                            "{}: {}",
                            "{}",
                            .{
                                std.zig.fmtId(param.name),
                                html.fmt_type(param.type),
                                fmt_docs(param.docs),
                            },
                        );
                    }
                    try html.end_dl();
                }

                if (item.errors.len > 0) {
                    try html.writer.print("<h2>Errors</h2>\n", .{});

                    try html.begin_dl();
                    for (item.errors) |err| {
                        try html.dl_item(
                            "{}",
                            "{}",
                            .{
                                std.zig.fmtId(err.name),
                                fmt_docs(err.docs),
                            },
                        );
                    }
                    try html.end_dl();
                }
            },
            .resource => |index| {
                const item = html.schema.resources[@intFromEnum(index)];
                _ = item;
                try html.writer.writeAll("<p>TODO: Implement resource</p>\n");
            },
            .constant => |index| {
                const item = html.schema.constants[@intFromEnum(index)];
                _ = item;
                try html.writer.writeAll("<p>TODO: Implement constant</p>\n");
            },
            .typedef => |index| {
                const item = html.schema.types[@intFromEnum(index)];
                _ = item;
                try html.writer.writeAll("<p>TODO: Implement typedef</p>\n");
            },
        }

        try html.render_basic_list(decl, "Namespaces", &.{.namespace});
        try html.render_basic_list(decl, "Types", &.{
            .@"struct",
            .@"union",
            .@"enum",
            .bitstruct,
            .resource,
            .typedef,
        });
        try html.render_basic_list(decl, "Constants", &.{.constant});
        try html.render_group(decl, "System Calls", .syscall);
        try html.render_group(decl, "Asynchronous Operations", .async_call);

        try html.writer.writeAll(
            \\        </section>
            \\
        );
    }

    fn begin_dl(html: *HtmlRenderer) !void {
        try html.writer.writeAll("<dl>\n");
    }
    fn end_dl(html: *HtmlRenderer) !void {
        try html.writer.writeAll("</dl>\n");
    }

    fn dl_item(html: *HtmlRenderer, comptime dt_fmt: []const u8, comptime dd_fmt: []const u8, args: anytype) !void {
        try html.writer.print(
            "<div>\n<dt><code>" ++ dt_fmt ++ "</code></dt><dd>" ++ dd_fmt ++ "</dd></div>\n",
            args,
        );
    }

    fn contains_tag(tag: model.Declaration.Kind, tags: []const model.Declaration.Kind) bool {
        for (tags) |t| {
            if (t == tag)
                return true;
        }
        return false;
    }

    pub fn render_basic_list(html: *HtmlRenderer, decl: model.Declaration, title: []const u8, tags: []const model.Declaration.Kind) !void {
        var count: usize = 0;
        for (decl.children) |child| {
            if (contains_tag(child.data, tags))
                count += 1;
        }

        if (count == 0)
            return;

        try html.writer.print("            <h2>{s}</h2>\n", .{title});

        try html.writer.writeAll("            <ul>\n");
        for (decl.children) |child| {
            if (!contains_tag(child.data, tags))
                continue;

            try html.writer.print(
                \\                <li><a href="#ashet.{[0]}">{[1]s}</a></li>
                \\
            , .{
                fmt_fqn(child.full_qualified_name),
                child.full_qualified_name[child.full_qualified_name.len - 1],
            });
        }
        try html.writer.writeAll("            </ul>\n");
    }

    pub fn render_group(html: *HtmlRenderer, decl: model.Declaration, title: []const u8, tag: model.Declaration.Kind) !void {
        var count: usize = 0;
        for (decl.children) |child| {
            if (child.data == tag)
                count += 1;
        }

        if (count == 0)
            return;

        try html.writer.print("            <h2>{s}</h2>\n", .{title});

        try html.writer.writeAll("            <dl>\n");
        for (decl.children) |child| {
            if (child.data != tag)
                continue;

            try html.writer.writeAll("                <div>\n");

            try html.writer.print(
                \\                    <dt><code><span class="tok-kw">{s}</span> <a href="#ashet.{s}"><span class="tok-name">{s}</span></a>(
            , .{
                @tagName(child.data),
                fmt_fqn(child.full_qualified_name),
                child.full_qualified_name[child.full_qualified_name.len - 1],
            });

            const maybe_function = switch (child.data) {
                .syscall => |index| html.schema.syscalls[@intFromEnum(index)],
                .async_call => |index| html.schema.async_calls[@intFromEnum(index)],
                else => null,
            };
            if (maybe_function) |function| {
                var has_any = false;

                for (function.inputs) |param| {
                    if (has_any) try html.writer.writeAll(", ");

                    try html.writer.print("<span class=\"tok-kw\">in</span> <span class=\"tok-name\">{s}</span>: {}", .{
                        param.name,
                        html.fmt_type(param.type),
                    });

                    has_any = true;
                }

                for (function.outputs) |param| {
                    if (has_any) try html.writer.writeAll(", ");

                    try html.writer.print("<span class=\"tok-kw\">out</span> <span class=\"tok-name\">{s}</span>: {}", .{
                        param.name,
                        html.fmt_type(param.type),
                    });

                    has_any = true;
                }

                try html.writer.writeAll(")");
                if (function.no_return) {
                    try html.writer.writeAll(" <span class=\"tok-kw\">noreturn</span>");
                }
            } else {
                try html.writer.writeAll(")");
            }
            try html.writer.writeAll("</code></dt>");

            if (child.docs.len > 0) {
                try html.writer.print(
                    \\                    <dd>{}</dd>
                    \\
                , .{
                    fmt_docs(child.docs),
                });
            }

            try html.writer.writeAll("                </div>\n");
        }
        try html.writer.writeAll("            </dl>\n");
    }

    fn fmt_type(html: *HtmlRenderer, type_id: model.TypeIndex) std.fmt.Formatter(format_type) {
        return .{ .data = .{ html, type_id } };
    }

    fn fmt_value(html: *HtmlRenderer, value: model.Value) std.fmt.Formatter(format_value) {
        return .{ .data = .{ html, value } };
    }

    fn fmt_known_type(writer: anytype, known_type: anytype) !void {
        try writer.print("<a href=\"#ashet.{}\"><span class=\"tok-type\">{s}</span></a>", .{
            fmt_fqn(known_type.full_qualified_name),
            fmt_fqn(known_type.full_qualified_name),
        });
    }

    fn format_type(packed_args: struct { *HtmlRenderer, model.TypeIndex }, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;

        const html: *HtmlRenderer, const type_id = packed_args;

        const type_ref = html.schema.types[@intFromEnum(type_id)];

        switch (type_ref) {
            .well_known => |name| try writer.print("<span class=\"tok-type\">{s}</span>", .{@tagName(name)}),
            .uint => |size| try writer.print("<span class=\"tok-type\">u{}</span>", .{size}),
            .int => |size| try writer.print("<span class=\"tok-type\">i{}</span>", .{size}),

            .@"struct" => |index| try fmt_known_type(writer, html.schema.structs[@intFromEnum(index)]),
            .@"union" => |index| try fmt_known_type(writer, html.schema.unions[@intFromEnum(index)]),
            .@"enum" => |index| try fmt_known_type(writer, html.schema.enums[@intFromEnum(index)]),
            .bitstruct => |index| try fmt_known_type(writer, html.schema.bitstructs[@intFromEnum(index)]),
            .resource => |index| try fmt_known_type(writer, html.schema.resources[@intFromEnum(index)]),

            .optional => |child| try writer.print("?{}", .{html.fmt_type(child)}),
            .array => |array| try writer.print("[{}]{}", .{ array.size, html.fmt_type(array.child) }),

            .alias => |child| try writer.print("{}", .{html.fmt_type(child)}),

            .ptr => |ptr| {
                try writer.writeAll(switch (ptr.size) {
                    .one => "*",
                    .slice => "[]",
                    .unknown => "[*]",
                });

                if (ptr.is_const) {
                    try writer.writeAll("<span class=\"tok-kw\">const</span> ");
                }

                if (ptr.alignment) |alignment| {
                    try writer.print("<span class=\"tok-kw\">align</span>({}) ", .{alignment});
                }

                try writer.print("{}", .{html.fmt_type(ptr.child)});
            },
            .fnptr,

            .external,
            .typedef,
            => try writer.writeAll("&lt;TODO&gt;"),

            .unknown_named_type => @panic("invalid schema!"),
            .unset_magic_type => @panic("invalid schema!"),
        }
    }

    fn format_value(packed_args: struct { *HtmlRenderer, model.Value }, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;

        _, const value = packed_args;

        switch (value) {
            .null => try writer.writeAll("<span class=\"tok-kw\">null</span>"),
            .bool => |val| try writer.print("{}", .{val}),
            .int => |int| try writer.print("{}", .{int}),
            .string => |text| try writer.print("\"{}\"", .{std.zig.fmtEscapes(text)}),
            .compound => try writer.writeAll("&lt;TODO%gt;"),
        }
    }
};

fn fmt_fqn(fqn: []const []const u8) std.fmt.Formatter(format_fqn) {
    return .{ .data = fqn };
}

fn format_fqn(fqn: []const []const u8, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
    _ = fmt;
    _ = options;
    for (fqn, 0..) |name, i| {
        if (i > 0)
            try writer.writeAll(".");
        try writer.writeAll(name);
    }
}

fn fmt_docs(docs: []const []const u8) std.fmt.Formatter(format_docs) {
    return .{ .data = docs };
}

fn format_docs(docs: []const []const u8, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
    if (docs.len == 0)
        return;

    _ = fmt;
    _ = options;

    const BlockType = enum { note, lore, relates };

    var last_was_empty = false;

    try writer.writeAll("<div class=\"doc-regular\"><p>");

    for (docs) |line| {
        if (line.len == 0) {
            last_was_empty = true;
            continue;
        }

        var requires_new_paragraph = false;

        if (last_was_empty) {
            requires_new_paragraph = true;
            last_was_empty = false;
        }

        var out_line = std.mem.trim(u8, line, " ");
        var change_block_type: ?BlockType = null;

        if (std.mem.startsWith(u8, out_line, "NOTE:")) {
            change_block_type = .note;
            requires_new_paragraph = true;
            out_line = out_line[5..];
        } else if (std.mem.startsWith(u8, out_line, "LORE:")) {
            change_block_type = .lore;
            requires_new_paragraph = true;
            out_line = out_line[5..];
        } else if (std.mem.startsWith(u8, out_line, "RELATES:")) {
            change_block_type = .relates;
            requires_new_paragraph = true;
            out_line = out_line[8..];
        }

        if (change_block_type) |block_type| {
            std.debug.assert(requires_new_paragraph == true);

            try writer.writeAll("</p></div>");

            try writer.print("<div class=\"docs docs-{s}\"><h3>{s}</h3><p>", .{
                @tagName(block_type),
                switch (block_type) {
                    .lore => "Lore:",
                    .note => "Note:",
                    .relates => "Related Elements:",
                },
            });
        } else if (requires_new_paragraph) {
            try writer.writeAll("</p>\n<p>");
        }

        out_line = std.mem.trimRight(u8, out_line, " \t\r\n");

        var in_code = false;
        for (out_line) |char| {
            switch (char) {
                '`' => {
                    in_code = !in_code;
                    if (in_code) {
                        try writer.writeAll("<code>");
                    } else {
                        try writer.writeAll("</code>");
                    }
                },
                else => try writer.writeByte(char),
            }
        }

        try writer.writeAll("\n");
    }
    try writer.writeAll("</p></div>");
}
