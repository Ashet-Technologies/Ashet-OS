const std = @import("std");
const abi_schema = @import("abi-parser");

const Mode = enum { userland, kernel, definition, stubs };

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    const allocator = arena.allocator();

    const argv = try std.process.argsAlloc(allocator);

    if (argv.len != 4)
        @panic("<exe> <mode> <input> <output>");

    const mode: Mode = std.meta.stringToEnum(Mode, argv[1]) orelse return error.InvalidMode;

    const json_txt = try std.fs.cwd().readFileAlloc(allocator, argv[2], 1 << 30);

    const schema = try abi_schema.Document.from_json_str(
        allocator,
        json_txt,
    );

    var output = try std.fs.cwd().atomicFile(argv[3], .{});
    defer output.deinit();

    const document = schema.value;

    switch (mode) {
        .userland => try render_userland(output.file.writer(), allocator, document),
        .kernel => try render_kernel(output.file.writer(), allocator, document),
        .definition => try render_definition(output.file.writer(), allocator, document),
        .stubs => try render_stubs(output.file.writer(), allocator, document),
    }

    try output.finish();
}

fn render_header(writer: std.fs.File.Writer) !void {
    try writer.writeAll(
        \\//!
        \\//! THIS CODE WAS AUTOGENERATED!
        \\//!
        \\
        \\
        \\
    );
}

pub fn render_definition(writer: std.fs.File.Writer, allocator: std.mem.Allocator, schema: abi_schema.Document) !void {
    try render_header(writer);
    _ = allocator;

    try writer.writeAll(
        \\
        \\//
        \\// The code beyond this is copied verbatim from the input file!
        \\//
        \\
        \\
    );
    try writer.writeAll(std.mem.trim(u8, schema.root_container.rest, " \r\n\t"));
    try writer.writeAll(
        \\
        \\//
        \\// The code beyond this is generated again
        \\//
        \\
        \\
    );

    try writer.writeAll("/// Asynchronous operation type, defines numeric values for AsyncOps.\n");
    try writer.writeAll("pub const ARC_Type = enum(u32) {\n");

    for (schema.iops) |iop| {
        try writer.print("    {} = {s},\n", .{ std.zig.fmtId(iop.full_qualified_name.?), iop.name });
    }

    try writer.writeAll("\n");

    try writer.writeAll("    pub fn as_type(comptime arc_type: @This()) type {\n");
    try writer.writeAll("        return switch(arc_type) {\n");
    //             for iop in sorted(abi.iops, key=lambda iop: iop.number.value):
    try writer.writeAll("            .{iop.key.value} => {iop.full_qualified_name.value},\n");
    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n");

    try writer.writeAll("\n");
    try writer.writeAll("};\n");
    // stream.writeln()
    // stream.writeln()
    // stream.writeln("const __SystemResourceType = enum(u16) {")
    // with stream.indent():
    //     # stream.writeln("bad_handle = 0,")

    //     for src in sys_resources:
    //         stream.writeln(f"{caseconverter.snakecase(src)},")

    // # stream.writeln("    _,")
    // stream.writeln("};")

    // stream.writeln()
    // stream.writeln("fn __SystemResourceCastResult(comptime t: __SystemResourceType) type {")
    // stream.writeln("    return switch (t) {")

    // for src in sys_resources:
    //     stream.writeln(f"        .{caseconverter.snakecase(src)} => {src},")

    // # stream.writeln("         _ => @compileError(\"Undefined type passed.\"),")
    // stream.writeln("    };")
    // stream.writeln("}")

    // stream.writeln()
}

pub fn render_userland(writer: std.fs.File.Writer, allocator: std.mem.Allocator, schema: abi_schema.Document) !void {
    try render_header(writer);
    _ = allocator;
    _ = schema;
}

pub fn render_kernel(writer: std.fs.File.Writer, allocator: std.mem.Allocator, schema: abi_schema.Document) !void {
    try render_header(writer);
    _ = allocator;
    _ = schema;
}

pub fn render_stubs(writer: std.fs.File.Writer, allocator: std.mem.Allocator, schema: abi_schema.Document) !void {
    _ = writer;
    _ = allocator;
    _ = schema;
}
