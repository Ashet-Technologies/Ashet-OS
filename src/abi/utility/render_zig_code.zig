const std = @import("std");
const abi_parser = @import("abi-parser");

const code_writer = @import("code_writer.zig");

const patch_parser = @import("patch_parser.zig");

const fmt_id = std.zig.fmtId;
const fmt_escapes = std.zig.fmtEscapes;

const model = abi_parser.model;

const Mode = enum { userland, kernel, definition };

const CodeWriter = code_writer.CodeWriter(std.fs.File.Writer);

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    const allocator = arena.allocator();

    const argv = try std.process.argsAlloc(allocator);

    if (argv.len < 4 or argv.len > 5)
        @panic("<exe> <mode> <input> <output> [<patch>]");

    const mode: Mode = std.meta.stringToEnum(Mode, argv[1]) orelse return error.InvalidMode;

    const json_txt = try std.fs.cwd().readFileAlloc(allocator, argv[2], 1 << 30);

    const patch_code = if (argv.len > 4)
        try std.fs.cwd().readFileAlloc(allocator, argv[4], 1 << 30)
    else
        "";

    const patch_set: patch_parser.PatchSet = try patch_parser.parse(allocator, patch_code);

    const schema = try model.from_json_str(allocator, json_txt);

    var output = try std.fs.cwd().atomicFile(argv[3], .{});
    defer output.deinit();

    var writer: CodeWriter = .init(output.file.writer());

    const document = schema.value;
    switch (mode) {
        .userland => try render_userland(&writer, allocator, document, patch_set),
        .kernel => try render_kernel(&writer, allocator, document, patch_set),
        .definition => try render_definition(&writer, allocator, document, patch_set),
    }

    try writer.flush();

    try output.finish();
}

fn render_header(writer: *CodeWriter) !void {
    try writer.writeln(
        \\//!
        \\//! THIS CODE WAS AUTOGENERATED!
        \\//!
        \\
        \\
    );
}

pub fn render_definition(writer: *CodeWriter, allocator: std.mem.Allocator, schema: model.Document, patch_set: patch_parser.PatchSet) !void {
    try render_header(writer);

    try writer.writeln(
        \\const std = @import("std");
        \\
        \\pub const platforms = @import("platforms");
        \\
        \\pub const Platform = platforms.Platform;
    );

    var renderer: ZigRenderer = .{
        .allocator = allocator,
        .writer = writer,
        .schema = &schema,
        .scope_prefix = "",
        .patch_set = patch_set,
    };

    try renderer.render_children(&.{}, schema.root);

    try writer.writeln("");

    try writer.writeln(
        \\/// Enumeration of all syscall numbers.
        \\pub const Syscall_ID = enum(u32) {
    );
    {
        writer.indent();
        defer writer.dedent();

        for (schema.syscalls) |syscall| {
            try writer.println("{_} = {},", .{ fmt_fqn(syscall.full_qualified_name), @intFromEnum(syscall.uid) });
        }
    }
    try writer.writeln("};");
    try writer.writeln("");
}

pub fn render_kernel(writer: *CodeWriter, allocator: std.mem.Allocator, schema: model.Document, patch_set: patch_parser.PatchSet) !void {
    try render_header(writer);

    var renderer: ZigRenderer = .{
        .allocator = allocator,
        .writer = writer,
        .schema = &schema,
        .scope_prefix = "abi.",
        .patch_set = patch_set,
    };

    try writer.write(
        \\const std = @import("std");
        \\const abi = @import("abi");
        \\
        \\pub const Syscall_ID = abi.Syscall_ID;
        \\
        \\/// This function creates a type that, when references,
        \\/// will export all ashet os systemcalls.
        \\///
        \\/// Syscalls will are expected to be in their respective
        \\/// namespace as in the ABI file.
        \\pub fn create_exports(comptime Impl: type, comptime Callbacks: type) type {
        \\
    );

    {
        writer.indent();
        defer writer.dedent();

        try writer.writeln("return struct {");
        {
            writer.indent();
            defer writer.dedent();

            for (schema.syscalls) |syscall| {
                try writer.print("pub export fn {s}{_}(", .{ renderer.symbol_prefix, fmt_fqn(syscall.full_qualified_name) });

                for (syscall.native_inputs, 0..) |input, index| {
                    if (index > 0)
                        try writer.write(", ");

                    try writer.print("{}: {}", .{
                        fmt_id(input.name),
                        renderer.fmt_type(input.type),
                    });
                }

                try writer.write(") ");

                const has_errors = (syscall.errors.len > 0);

                if (syscall.native_outputs.len > 0) {
                    std.debug.assert(syscall.native_outputs.len == 1);
                    try writer.print("{}", .{renderer.fmt_type(syscall.native_outputs[0].type)});
                } else {
                    std.debug.assert(!has_errors);
                    try writer.write("void");
                }

                try writer.writeln(" {");

                {
                    writer.indent();
                    defer writer.dedent();

                    try writer.println("Callbacks.before_syscall(.{_});", .{fmt_fqn(syscall.full_qualified_name)});
                    try writer.println("defer Callbacks.after_syscall(.{_});", .{fmt_fqn(syscall.full_qualified_name)});

                    if (has_errors) {
                        // the return value must be an error union
                        try writer.write("const __err_or_result: error{");

                        for (syscall.errors, 0..) |err, i| {
                            if (i > 0) {
                                try writer.write(",");
                            }
                            try writer.print("{}", .{
                                fmt_id(err.name),
                            });
                        }

                        try writer.write("}!");
                    } else {
                        // the return value must be a regular value
                        try writer.write("const __result: ");
                    }

                    if (syscall.logic_outputs.len > 0) {
                        std.debug.assert(syscall.logic_outputs.len == 1);
                        try writer.print("{}", .{
                            renderer.fmt_type(syscall.logic_outputs[0].type),
                        });
                    } else {
                        try writer.write("void");
                    }

                    try writer.println(" = Impl.{}(", .{
                        fmt_fqn(syscall.full_qualified_name),
                    });
                    {
                        writer.indent();
                        defer writer.dedent();

                        for (syscall.logic_inputs) |param| {
                            switch (param.role) {
                                .default => {
                                    try writer.println("{},", .{fmt_id(param.name)});
                                },
                                .input_slice => |slice| {
                                    if (schema.get_type(param.type).* == .optional) {
                                        try writer.println("if({}) |__ptr| __ptr[0..{}] else null,", .{ fmt_id(slice.ptr), fmt_id(slice.len) });
                                    } else {
                                        try writer.println("{}[0..{}],", .{ fmt_id(slice.ptr), fmt_id(slice.len) });
                                    }
                                },
                                else => unreachable,
                            }
                        }
                    }

                    try writer.writeln(");");

                    if (has_errors) {
                        try writer.writeln("if(__err_or_result) |__result| {");
                        writer.indent();
                    }

                    // TODO: Reassemble slice type if necessary!

                    if (has_errors) {
                        if (syscall.logic_outputs.len > 0) {
                            std.debug.assert(syscall.logic_outputs.len == 1);

                            for (syscall.logic_outputs) |param| {
                                const param_type = schema.get_type(param.type).*;

                                switch (param.role) {
                                    .default => {
                                        try writer.println("{}.* = __result;", .{
                                            fmt_id(param.name),
                                        });
                                    },
                                    .output_slice => |slice| {
                                        if (param_type == .optional) {
                                            try writer.println("{}.* = if(__result) |__slice| __slice.ptr else null;", .{
                                                fmt_id(slice.ptr),
                                            });
                                            try writer.println("{}.* = if(__result) |__slice| __slice.len else null;", .{
                                                fmt_id(slice.len),
                                            });
                                        } else {
                                            try writer.println("{}.* = __result.ptr;", .{
                                                fmt_id(slice.ptr),
                                            });
                                            try writer.println("{}.* = __result.len;", .{
                                                fmt_id(slice.len),
                                            });
                                        }
                                    },

                                    .output => unreachable,
                                    .output_ptr => unreachable,
                                    .output_len => unreachable,

                                    else => {},
                                }
                            }
                        } else {
                            try writer.writeln("_ = __result;");
                        }
                        try writer.writeln("return 0;");

                        writer.dedent();
                        try writer.writeln("} else |__error| {");
                        writer.indent();

                        try writer.writeln("return switch(__error) {");
                        writer.indent();

                        for (syscall.errors) |err| {
                            try writer.println("error.{} => {},", .{
                                fmt_id(err.name),
                                err.value,
                            });
                        }

                        writer.dedent();
                        try writer.writeln("};");

                        writer.dedent();
                        try writer.writeln("}");
                    } else {
                        try writer.writeln("return __result;");
                    }
                }
                try writer.writeln("}");
                try writer.writeln("");
            }
        }

        try writer.writeln("};");
    }
    try writer.writeln("}");
    try writer.writeln("");
}

pub fn render_userland(writer: *CodeWriter, allocator: std.mem.Allocator, schema: model.Document, patch_set: patch_parser.PatchSet) !void {
    try render_header(writer);

    var renderer: ZigRenderer = .{
        .allocator = allocator,
        .writer = writer,
        .schema = &schema,
        .scope_prefix = "abi.",
        .patch_set = patch_set,
    };

    try writer.write(
        \\const std = @import("std");
        \\const abi = @import("abi");
        \\
        \\pub const Syscall_ID = abi.Syscall_ID;
        \\
        \\fn __handle_unexpected(syscall: abi.Syscall_ID, error_code: u16) error{Unexpected} {
        \\    std.debug.assert(error_code != 0);
        \\    std.log.scoped(.ashet_syscalls).err("syscall {s} returned unexpected error code {}", .{ @tagName(syscall), error_code });
        \\    return error.Unexpected;
        \\}
        \\
        \\
    );

    try renderer.render_userland(schema.root);

    try writer.writeln("");
    try writer.writeln("");

    for (schema.syscalls) |syscall| {
        try renderer.render_syscall(&syscall, &.{}, .full_name);
    }
}

const ZigRenderer = struct {
    const Error = CodeWriter.Error;

    writer: *CodeWriter,
    allocator: std.mem.Allocator,
    schema: *const model.Document,
    scope_prefix: []const u8,
    symbol_prefix: []const u8 = "ashet_syscalls_",
    patch_set: patch_parser.PatchSet,

    fn render_userland(zr: *ZigRenderer, children: []const model.Declaration) Error!void {
        for (children, 0..) |child, index| {
            const is_first = (index == 0);

            if (!is_first) {
                try zr.writer.writeln("");
            }

            try zr.render_docs(child.docs);

            switch (child.data) {
                .namespace => {
                    try zr.writer.println("pub const {} = struct {{", .{fmt_id(model.local_name(child.full_qualified_name))});

                    {
                        zr.writer.indent();
                        defer zr.writer.dedent();

                        try zr.render_userland(child.children);
                    }

                    try zr.writer.writeln("};");
                },
                .@"struct", .@"union", .@"enum", .bitstruct, .resource, .async_call, .constant, .typedef => {
                    try zr.writer.println("pub const {} = {s}{};", .{
                        fmt_id(model.local_name(child.full_qualified_name)),
                        zr.scope_prefix,
                        fmt_fqn(child.full_qualified_name),
                    });
                },

                .syscall => |idx| try zr.render_userland_call(zr.schema.get_syscall(idx), child.children),
            }
        }
    }

    fn render_userland_call(zr: *ZigRenderer, syscall: *const model.GenericCall, children: []const model.Declaration) !void {
        std.debug.assert(children.len == 0);

        const writer = zr.writer;

        const has_errors = (syscall.errors.len > 0);

        try writer.println("pub fn {}(", .{
            fmt_id(model.local_name(syscall.full_qualified_name)),
        });

        {
            writer.indent();
            defer writer.dedent();

            for (syscall.logic_inputs) |input| {
                try zr.render_docs(input.docs);
                try writer.print("{}: {},", .{
                    fmt_id(input.name),
                    zr.fmt_type(input.type),
                });
                if (input.default) |default| {
                    try writer.print(" // = {}", .{zr.fmt_value(default)});
                }
                try writer.writeln("");
            }
        }
        try writer.write(") ");

        if (has_errors) {
            try writer.write("error{Unexpected");
            for (syscall.errors) |err| {
                try writer.print(",{}", .{fmt_id(err.name)});
            }
            try writer.write("}!");
        }

        if (syscall.logic_outputs.len == 1) {
            const retval = syscall.logic_outputs[0];

            try writer.print("{}", .{zr.fmt_type(retval.type)});
        } else {
            std.debug.assert(syscall.logic_outputs.len == 0);
            try writer.write("void");
        }

        try writer.writeln(" {");

        writer.indent();
        {
            var output_mode: enum { none, value, slice } = .none;

            for (syscall.native_inputs) |param| {
                switch (param.role) {
                    .default => {},
                    .output, .output_ptr, .output_len => {
                        std.debug.assert(output_mode == .none or output_mode == .slice);
                        if (param.role == .output) {
                            output_mode = .value;
                        } else {
                            output_mode = .slice;
                        }
                        const ptr_type = zr.schema.get_type(param.type).*;
                        std.debug.assert(ptr_type == .ptr);
                        std.debug.assert(ptr_type.ptr.size == .one);
                        std.debug.assert(ptr_type.ptr.is_const == false);

                        try writer.println("var {}: {} = undefined;", .{
                            fmt_local(param.name),
                            zr.fmt_type(ptr_type.ptr.child),
                        });
                    },

                    .input_ptr, .input_len => {},

                    else => std.log.err("unsupported role: {}", .{param.role}),
                }
            }

            try writer.println("const __result = {s}{_}(", .{
                zr.symbol_prefix,
                fmt_fqn(syscall.full_qualified_name),
            });
            writer.indent();

            for (syscall.native_inputs) |param| {
                const param_type = zr.schema.get_type(param.type).*;
                switch (param.role) {
                    .default => try writer.print("{}", .{fmt_id(param.name)}),
                    .output, .output_ptr, .output_len => try writer.print("&{}", .{fmt_local(param.name)}),

                    .input_ptr => |src_param| {
                        if (param_type == .optional) {
                            try writer.print("if({}) |__slice| __slice.ptr else null", .{fmt_id(src_param)});
                        } else {
                            try writer.print("{}.ptr", .{fmt_id(src_param)});
                        }
                    },
                    .input_len => |src_param| {
                        if (param_type == .optional) {
                            try writer.print("if({}) |__slice| __slice.len else null,", .{fmt_id(src_param)});
                        } else {
                            try writer.print("{}.len", .{fmt_id(src_param)});
                        }
                    },

                    else => std.log.err("unsupported role: {}", .{param.role}),
                }

                try writer.writeln(",");
            }
            writer.dedent();
            try writer.writeln(");");

            if (has_errors) {
                try writer.writeln("switch(__result) {");
                writer.indent();
                try writer.writeln("0 => {},");
                for (syscall.errors) |err| {
                    try writer.println("{} => return error.{},", .{
                        err.value,
                        fmt_id(err.name),
                    });
                }
                try writer.println("else => return __handle_unexpected(.{_}, __result),", .{
                    fmt_fqn(syscall.full_qualified_name),
                });
                writer.dedent();
                try writer.writeln("}");
            }

            if (syscall.logic_outputs.len > 0) {
                std.debug.assert(syscall.logic_outputs.len == 1);

                const output = syscall.logic_outputs[0];

                switch (output.role) {
                    .default => if (has_errors) {
                        try writer.println("return {};", .{fmt_local(output.name)});
                    } else {
                        try writer.writeln("return __result;");
                    },
                    .output_slice => |slice| {
                        const param_type = zr.schema.get_type(output.type).*;
                        if (param_type == .optional) {
                            try writer.println("return if({}) |__ptr| __ptr[0..{}] else null;", .{
                                fmt_local(slice.ptr),
                                fmt_local(slice.len),
                            });
                        } else {
                            try writer.println("return {}[0..{}];", .{
                                fmt_local(slice.ptr),
                                fmt_local(slice.len),
                            });
                        }
                    },
                    else => std.log.err("output {} role: {}", .{ zr.fmt_type(output.type), output.role }),
                }
            } else if (!has_errors) {
                try writer.writeln("_ = __result;");
            }
        }

        writer.dedent();

        try writer.writeln("}");
    }

    fn render_children(zr: *ZigRenderer, scope: model.FQN, children: []const model.Declaration) Error!void {
        for (children, 0..) |child, index| {
            const is_first = (index == 0);

            if (!is_first) {
                try zr.writer.writeln("");
            }

            try zr.render_docs(child.docs);

            switch (child.data) {
                .namespace => {
                    try zr.writer.println("pub const {} = struct {{", .{fmt_id(model.local_name(child.full_qualified_name))});

                    {
                        zr.writer.indent();
                        defer zr.writer.dedent();

                        try zr.render_children(child.full_qualified_name, child.children);
                    }

                    try zr.writer.writeln("};");
                },
                .@"struct" => |idx| try zr.render_struct_or_union(zr.schema.get_struct(idx), child.children, .@"struct"),
                .@"union" => |idx| try zr.render_struct_or_union(zr.schema.get_union(idx), child.children, .@"union"),
                .@"enum" => |idx| try zr.render_enum(zr.schema.get_enum(idx), child.children),
                .bitstruct => |idx| try zr.render_bitstruct(zr.schema.get_bitstruct(idx), child.children),

                .resource => |idx| try zr.render_resource(zr.schema.get_resource(idx), child.children),
                .constant => |idx| try zr.render_constant(zr.schema.get_constant(idx), child.children),
                .typedef => |idx| try zr.render_typedef(zr.schema.get_type(idx).typedef, child.children),

                .syscall => |idx| try zr.render_syscall(zr.schema.get_syscall(idx), child.children, .local_name),
                .async_call => |idx| try zr.render_async_call(zr.schema.get_async_call(idx), child.children),
            }
        }

        if (zr.patch_set.get(scope)) |patch| {
            try zr.writer.writeln(patch.patch_code);
        }
    }

    fn render_syscall(zr: *ZigRenderer, syscall: *const model.GenericCall, children: []const model.Declaration, symbol_name: enum { full_name, local_name }) !void {
        std.debug.assert(children.len == 0);

        switch (symbol_name) {
            .local_name => try zr.writer.println("pub extern fn {}(", .{
                fmt_id(model.local_name(syscall.full_qualified_name)),
            }),
            .full_name => try zr.writer.println("extern fn {s}{_}(", .{
                zr.symbol_prefix,
                fmt_fqn(syscall.full_qualified_name),
            }),
        }

        {
            zr.writer.indent();
            defer zr.writer.dedent();

            for (syscall.native_inputs) |input| {
                try zr.render_docs(input.docs);
                try zr.writer.print("{}: {},", .{
                    fmt_id(input.name),
                    zr.fmt_type(input.type),
                });
                if (input.default) |default| {
                    try zr.writer.print(" // = {}", .{zr.fmt_value(default)});
                }
                try zr.writer.writeln("");
            }
        }
        try zr.writer.write(") ");

        if (syscall.native_outputs.len == 1) {
            const retval = syscall.native_outputs[0];

            try zr.writer.print("{}", .{zr.fmt_type(retval.type)});
        } else {
            try zr.writer.write("void");
            std.debug.assert(syscall.native_outputs.len == 0);
        }

        try zr.writer.writeln(";");
    }

    fn render_async_call(zr: *ZigRenderer, arc: *const model.GenericCall, children: []const model.Declaration) !void {
        try zr.writer.println("pub const {} = extern struct {{", .{
            fmt_id(model.local_name(arc.full_qualified_name)),
        });

        {
            zr.writer.indent();
            defer zr.writer.dedent();

            try zr.writer.println("pub const arc_type: overlapped.ARC.Type = .{_};", .{
                fmt_snake_fqn(arc.full_qualified_name),
            });

            try zr.writer.writeln("");
            try zr.writer.writeln("pub const Inputs = extern struct {");

            zr.writer.indent();
            try zr.writer.println("pub const Overlapped = {};", .{fmt_fqn(arc.full_qualified_name)});
            for (arc.native_inputs) |field| {
                try zr.render_docs(field.docs);
                try zr.writer.print("{}: {}", .{
                    fmt_id(field.name),
                    zr.fmt_type(field.type),
                });
                if (field.default) |default| {
                    try zr.writer.print(" = {}", .{zr.fmt_value(default)});
                }
                try zr.writer.writeln(",");
            }
            zr.writer.dedent();
            try zr.writer.writeln("};");
            try zr.writer.writeln("");

            try zr.writer.writeln("pub const Outputs = extern struct {");
            zr.writer.indent();
            try zr.writer.println("pub const Overlapped = {};", .{fmt_fqn(arc.full_qualified_name)});
            for (arc.native_outputs) |field| {
                try zr.render_docs(field.docs);
                try zr.writer.print("{}: {}", .{
                    fmt_id(field.name),
                    zr.fmt_type(field.type),
                });
                if (field.default) |default| {
                    try zr.writer.print(" = {}", .{zr.fmt_value(default)});
                }
                try zr.writer.writeln(",");
            }
            zr.writer.dedent();
            try zr.writer.writeln("};");
            try zr.writer.writeln("");

            try zr.writer.writeln("pub const ErrorCode = enum(u16) {");
            try zr.writer.writeln("    success = 0,");
            for (arc.errors) |err| {
                try zr.writer.println("    {} = {},", .{ fmt_id(err.name), err.value });
            }
            try zr.writer.writeln("    _,");
            try zr.writer.writeln("};");
            try zr.writer.writeln("pub const Error = error{");
            for (arc.errors) |err| {
                try zr.writer.println("    {},", .{fmt_id(err.name)});
            }
            try zr.writer.writeln("};");
            try zr.writer.writeln("");

            try zr.writer.writeln("arc: overlapped.ARC,");
            try zr.writer.writeln("inputs: Inputs,");
            try zr.writer.writeln("outputs: Outputs,");
            try zr.writer.writeln("error_code: ErrorCode,");
            try zr.writer.writeln("");

            try zr.writer.writeln("pub fn new(inputs: Inputs) @This() {");
            {
                zr.writer.indent();
                defer zr.writer.dedent();
                try zr.writer.writeln("return .{");
                try zr.writer.println("    .arc = .{{ .type = .{_}, .tag = 0 }},", .{
                    fmt_snake_fqn(arc.full_qualified_name),
                });
                try zr.writer.writeln("    .inputs = inputs,");
                try zr.writer.writeln("    .outputs = undefined,");
                try zr.writer.writeln("    .error_code = .success,");
                try zr.writer.writeln("};");
            }
            try zr.writer.writeln("}");

            try zr.writer.write("pub fn init(");

            for (arc.logic_inputs, 0..) |field, i| {
                if (i > 0)
                    try zr.writer.write(", ");
                try zr.writer.print("{}: {}", .{
                    fmt_id(field.name),
                    zr.fmt_type(field.type),
                });
            }

            try zr.writer.writeln(") @This() {");
            {
                zr.writer.indent();
                defer zr.writer.dedent();
                try zr.writer.writeln("return .{");

                try zr.writer.println("    .arc = .{{ .type = .{_}, .tag = 0 }},", .{
                    fmt_snake_fqn(arc.full_qualified_name),
                });
                try zr.writer.writeln("    .inputs = .{");
                for (arc.native_inputs) |field| {
                    switch (field.role) {
                        .default => try zr.writer.println("        .{[0]} = {[0]},", .{
                            fmt_id(field.name),
                        }),
                        .input_ptr => |src_param| try zr.writer.println("        .{[0]} = {[1]}.ptr,", .{
                            fmt_id(field.name),
                            fmt_id(src_param),
                        }),
                        .input_len => |src_param| try zr.writer.println("        .{[0]} = {[1]}.len,", .{
                            fmt_id(field.name),
                            fmt_id(src_param),
                        }),
                        else => unreachable,
                    }
                }
                try zr.writer.writeln("    },");
                try zr.writer.writeln("    .outputs = undefined,");
                try zr.writer.writeln("    .error_code = .success,");
                try zr.writer.writeln("};");
            }
            try zr.writer.writeln("}");

            try zr.writer.writeln("");
            try zr.writer.writeln("pub fn check_error(arc: @This()) !void {");
            zr.writer.indent();
            try zr.writer.writeln("return switch(arc.error_code) {");
            zr.writer.indent();
            try zr.writer.writeln(".success => {},");
            for (arc.errors) |err| {
                try zr.writer.println(".{} => error.{},", .{ fmt_id(err.name), fmt_id(err.name) });
            }
            try zr.writer.writeln("_ => error.Unexpected,");
            zr.writer.dedent();
            try zr.writer.writeln("};");
            zr.writer.dedent();
            try zr.writer.writeln("}");
            try zr.writer.writeln("");
            try zr.writer.writeln("pub fn from_arc(arc: *overlapped.ARC) *@This() {");
            zr.writer.indent();
            try zr.writer.println("std.debug.assert(arc.type == .{_});", .{
                fmt_snake_fqn(arc.full_qualified_name),
            });
            try zr.writer.writeln("return @alignCast(@fieldParentPtr(\"arc\", arc));");
            zr.writer.dedent();
            try zr.writer.writeln("}");
            try zr.writer.writeln("");
            try zr.writer.writeln("pub fn set_ok(arc: *@This()) void {");
            zr.writer.indent();
            try zr.writer.writeln("arc.error_code = .success;");
            zr.writer.dedent();
            try zr.writer.writeln("}");
            try zr.writer.writeln("");
            try zr.writer.writeln("pub fn set_error(arc: *@This(), err: Error) void {");
            zr.writer.indent();
            try zr.writer.writeln("arc.error_code = switch(err) {");
            for (arc.errors) |err| {
                try zr.writer.println("error.{} => .{},", .{ fmt_id(err.name), fmt_id(err.name) });
            }
            try zr.writer.writeln("};");
            try zr.writer.writeln("std.debug.assert(arc.error_code != .success);");
            zr.writer.dedent();
            try zr.writer.writeln("}");
            try zr.writer.writeln("");

            try zr.render_children(arc.full_qualified_name, children);
        }

        try zr.writer.writeln("};");
    }

    fn render_struct_or_union(zr: *ZigRenderer, container: *const model.Struct, children: []const model.Declaration, container_type: enum { @"struct", @"union" }) !void {
        try zr.writer.println("pub const {} = extern {s} {{", .{
            fmt_id(model.local_name(container.full_qualified_name)),
            @tagName(container_type),
        });

        {
            zr.writer.indent();
            defer zr.writer.dedent();

            for (container.native_fields) |field| {
                try zr.render_docs(field.docs);
                try zr.writer.print("{}: {}", .{ fmt_id(field.name), zr.fmt_type(field.type) });
                if (field.default) |default| {
                    try zr.writer.print(" = {}", .{zr.fmt_value(default)});
                }
                try zr.writer.writeln(",");
            }

            try zr.render_children(container.full_qualified_name, children);
        }

        try zr.writer.writeln("};");
    }

    fn render_bitstruct(zr: *ZigRenderer, container: *const model.BitStruct, children: []const model.Declaration) !void {
        try zr.writer.println("pub const {} = packed struct({s}) {{", .{
            fmt_id(model.local_name(container.full_qualified_name)),
            @tagName(container.backing_type),
        });

        {
            zr.writer.indent();
            defer zr.writer.dedent();

            var reserved_idx: usize = 0;
            for (container.fields) |field| {
                var reserved_buf: [32]u8 = undefined;
                const reserved_id = try std.fmt.bufPrint(&reserved_buf, "_reserved{}", .{reserved_idx});

                try zr.render_docs(field.docs);
                try zr.writer.print("{}: {}", .{ fmt_id(field.name orelse reserved_id), zr.fmt_type(field.type) });
                if (field.default) |default| {
                    try zr.writer.print(" = {}", .{zr.fmt_value(default)});
                }
                try zr.writer.writeln(",");

                if (field.name == null) {
                    reserved_idx += 1;
                }
            }

            try zr.render_children(container.full_qualified_name, children);
        }

        try zr.writer.writeln("};");
    }

    fn render_enum(zr: *ZigRenderer, container: *const model.Enumeration, children: []const model.Declaration) !void {
        try zr.writer.println("pub const {} = enum({s}) {{", .{
            fmt_id(model.local_name(container.full_qualified_name)),
            @tagName(container.backing_type),
        });

        {
            zr.writer.indent();
            defer zr.writer.dedent();

            for (container.items) |item| {
                try zr.render_docs(item.docs);
                try zr.writer.println("{} = {},", .{ fmt_id(item.name), item.value });
            }

            switch (container.kind) {
                .closed => {},
                .open => try zr.writer.writeln("_,"),
            }

            try zr.render_children(container.full_qualified_name, children);
        }

        try zr.writer.writeln("};");
    }

    fn render_resource(zr: *ZigRenderer, container: *const model.Resource, children: []const model.Declaration) !void {
        const writer = zr.writer;

        try writer.println("pub const {} = enum(usize) {{", .{
            fmt_id(model.local_name(container.full_qualified_name)),
        });

        {
            writer.indent();
            defer writer.dedent();

            try writer.writeln("_,");

            try writer.writeln("pub fn as_resource(self: @This()) SystemResource {");
            writer.indent();
            try writer.writeln("return @enumFromInt(@intFromEnum(self));");
            writer.dedent();
            try writer.writeln("}");
            try writer.writeln("");
            try writer.writeln("pub fn release(self: @This()) void {");
            writer.indent();
            try writer.writeln("resources.release(self.as_resource());");
            writer.dedent();
            try writer.writeln("}");
            try writer.writeln("");
            try writer.writeln("pub fn destroy_now(self: @This()) void {");
            writer.indent();
            try writer.writeln("resources.destroy(self.as_resource());");
            writer.dedent();
            try writer.writeln("}");
            try writer.writeln("");
            try writer.writeln("pub fn format(res: @This(), fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {");
            writer.indent();
            try writer.writeln("_ = fmt;");
            try writer.writeln("_ = options;");
            try writer.println("try writer.print(\"{}(0x{{X:0>8}})\", .{{ @intFromEnum(res) }});", .{
                fmt_escapes(model.local_name(container.full_qualified_name)),
            });
            writer.dedent();
            try writer.writeln("}");

            try zr.render_children(container.full_qualified_name, children);
        }

        try zr.writer.writeln("};");
    }

    fn render_constant(zr: *ZigRenderer, container: *const model.Constant, children: []const model.Declaration) !void {
        std.debug.assert(children.len == 0);

        try zr.writer.print("pub const {}", .{
            fmt_id(model.local_name(container.full_qualified_name)),
        });

        if (container.type) |ctype| {
            try zr.writer.print(": {}", .{zr.fmt_type(ctype)});
        }

        try zr.writer.println("= {};", .{zr.fmt_value(container.value)});
    }

    fn render_typedef(zr: *ZigRenderer, container: model.TypeDefition, children: []const model.Declaration) !void {
        std.debug.assert(children.len == 0);

        try zr.writer.println("pub const {} = {};", .{
            fmt_id(model.local_name(container.full_qualified_name)),
            zr.fmt_type(container.alias),
        });
    }

    fn render_docs(zr: *ZigRenderer, docs: model.DocString) !void {
        for (docs) |line| {
            try zr.writer.println("/// {s}", .{line});
        }
    }

    fn fmt_type(zr: *ZigRenderer, type_id: model.TypeIndex) std.fmt.Formatter(format_type) {
        return .{ .data = .{ zr, type_id } };
    }

    fn fmt_type_val(zr: *ZigRenderer, type_val: model.Type) std.fmt.Formatter(format_type_val) {
        return .{ .data = .{ zr, type_val } };
    }

    fn format_type(pack: struct { *ZigRenderer, model.TypeIndex }, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        const zr: *ZigRenderer, const type_id: model.TypeIndex = pack;

        const type_val = zr.schema.get_type(type_id);

        try format_type_val(.{ zr, type_val.* }, fmt, options, writer);
    }

    fn format_type_val(pack: struct { *ZigRenderer, model.Type }, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;

        const zr: *ZigRenderer, const type_val: model.Type = pack;

        switch (type_val) {
            .alias => |child| try writer.print("{}", .{zr.fmt_type(child)}),

            .well_known => |id| try writer.writeAll(switch (id) {
                .void => "void",
                .bool => "bool",
                .noreturn => "noreturn",
                .anyptr => "*anyopaque",
                .anyfnptr => "*const anyopaque", // TODO?
                .str => "[]const u8",
                .bytestr => "[]const u8",
                .bytebuf => "[]u8",
                .u8 => "u8",
                .u16 => "u16",
                .u32 => "u32",
                .u64 => "u64",
                .usize => "usize",
                .i8 => "i8",
                .i16 => "i16",
                .i32 => "i32",
                .i64 => "i64",
                .isize => "isize",
                .f32 => "f32",
                .f64 => "f64",
            }),

            .optional => |child| try writer.print("?{}", .{zr.fmt_type(child)}),

            .array => |arr| try writer.print("[{}]{}", .{ arr.size, zr.fmt_type(arr.child) }),

            .ptr => |ptr| {
                try writer.writeAll(switch (ptr.size) {
                    .one => "*",
                    .slice => "[]",
                    .unknown => "[*]",
                });

                if (ptr.is_const) {
                    try writer.writeAll("const ");
                }
                if (ptr.alignment) |alignment| {
                    try writer.print("align({}) ", .{alignment});
                }

                try writer.print("{}", .{zr.fmt_type(ptr.child)});
            },

            .@"enum" => |index| try writer.print("{s}{}", .{
                zr.scope_prefix,
                fmt_fqn(zr.schema.get_enum(index).full_qualified_name),
            }),

            .@"struct" => |index| try writer.print("{s}{}", .{
                zr.scope_prefix,
                fmt_fqn(zr.schema.get_struct(index).full_qualified_name),
            }),

            .@"union" => |index| try writer.print("{s}{}", .{
                zr.scope_prefix,
                fmt_fqn(zr.schema.get_union(index).full_qualified_name),
            }),

            .bitstruct => |index| try writer.print("{s}{}", .{
                zr.scope_prefix,
                fmt_fqn(zr.schema.get_bitstruct(index).full_qualified_name),
            }),

            .resource => |index| try writer.print("{s}{}", .{
                zr.scope_prefix,
                fmt_fqn(zr.schema.get_resource(index).full_qualified_name),
            }),

            .typedef => |typedef| try writer.print("{s}{}", .{
                zr.scope_prefix,
                fmt_fqn(typedef.full_qualified_name),
            }),

            .uint => |size| try writer.print("u{}", .{size}),
            .int => |size| try writer.print("i{}", .{size}),

            .fnptr => |fptr| {
                try writer.writeAll("*const fn(");
                for (fptr.parameters, 0..) |ptype, i| {
                    if (i > 0) {
                        try writer.writeAll(", ");
                    }
                    try writer.print("{}", .{zr.fmt_type(ptype)});
                }
                try writer.writeAll(") callconv(.c) ");

                try writer.print("{}", .{zr.fmt_type(fptr.return_type)});
            },

            .external => try writer.print("<<{s}>>", .{@tagName(type_val)}),

            .unknown_named_type, .unset_magic_type => @panic("invalid model"),
        }
    }

    fn fmt_value(zr: *ZigRenderer, value: model.Value) std.fmt.Formatter(format_value) {
        return .{ .data = .{ zr, value } };
    }

    fn format_value(pack: struct { *ZigRenderer, model.Value }, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        const zr: *ZigRenderer, const value: model.Value = pack;

        _ = fmt;
        _ = options;

        switch (value) {
            .null => try writer.writeAll("null"),

            .bool => |b| try writer.print("{}", .{b}),

            .string => |str| try writer.print("\"{}\"", .{fmt_escapes(str)}),

            .int => |i| try writer.print("{}", .{i}),

            .compound => |compound| {
                try writer.writeAll(".{");

                for (compound.fields.keys(), compound.fields.values(), 0..) |fld_name, fld_value, i| {
                    if (i > 0) {
                        try writer.writeAll(", ");
                    }

                    try writer.print(".{} = {}", .{
                        fmt_id(fld_name),
                        zr.fmt_value(fld_value),
                    });
                }

                try writer.writeAll("}");
            },
        }
    }
};

fn fmt_fqn(fqn: []const []const u8) std.fmt.Formatter(format_fqn) {
    return .{ .data = fqn };
}

fn format_fqn(fqn: []const []const u8, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
    _ = options;
    for (fqn, 0..) |name, i| {
        if (i > 0) {
            try writer.writeAll(if (fmt.len > 0) fmt else ".");
        }
        try writer.writeAll(name);
    }
}

fn fmt_local(id: []const u8) std.fmt.Formatter(format_local) {
    return .{ .data = id };
}

fn format_local(id: []const u8, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
    var buf: [1024]u8 = undefined;

    const local_id = try std.fmt.bufPrint(&buf, "_L_{s}", .{id});
    _ = fmt;
    _ = options;

    try writer.print("{}", .{fmt_id(local_id)});
}

fn fmt_snake_fqn(fqn: []const []const u8) std.fmt.Formatter(format_snake_fqn) {
    return .{ .data = fqn };
}

fn format_snake_fqn(fqn: []const []const u8, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
    _ = fmt;
    _ = options;
    for (fqn, 0..) |local_name, i| {
        if (i > 0) {
            try writer.writeByte('_');
        }

        for (local_name, 0..) |c, j| {
            if (j > 0 and std.ascii.isUpper(c)) {
                try writer.writeByte('_');
            }
            try writer.writeByte(std.ascii.toLower(c));
        }
    }
}
