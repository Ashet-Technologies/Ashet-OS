const std = @import("std");
const abi_parser = @import("abi-parser");

const code_writer = @import("code_writer.zig");

const model = abi_parser.model;

const Mode = enum { userland, kernel, definition, stubs };

const CodeWriter = code_writer.CodeWriter(std.fs.File.Writer);

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    const allocator = arena.allocator();

    const argv = try std.process.argsAlloc(allocator);

    if (argv.len != 4)
        @panic("<exe> <mode> <input> <output>");

    const mode: Mode = std.meta.stringToEnum(Mode, argv[1]) orelse return error.InvalidMode;

    const json_txt = try std.fs.cwd().readFileAlloc(allocator, argv[2], 1 << 30);

    const schema = try model.from_json_str(allocator, json_txt);

    var output = try std.fs.cwd().atomicFile(argv[3], .{});
    defer output.deinit();

    var writer: CodeWriter = .init(output.file.writer());

    const document = schema.value;
    switch (mode) {
        .userland => try render_userland(&writer, allocator, document),
        .kernel => try render_kernel(&writer, allocator, document),
        .definition => try render_definition(&writer, allocator, document),
        .stubs => try render_stubs(&writer, allocator, document),
    }

    try writer.flush();

    try output.finish();
}

fn render_header(writer: *CodeWriter) !void {
    try writer.writeln(
        \\//!
        \\//! THIS CODE WAS AUTOGENERATED!
        \\//!
        \\
        \\
    );
}

pub fn render_definition(writer: *CodeWriter, allocator: std.mem.Allocator, schema: model.Document) !void {
    try render_header(writer);

    var renderer: ZigRenderer = .{
        .allocator = allocator,
        .writer = writer,
        .schema = &schema,
    };

    try renderer.render_children(schema.root);
}

pub fn render_userland(writer: *CodeWriter, allocator: std.mem.Allocator, schema: model.Document) !void {
    try render_header(writer);
    _ = allocator;
    _ = schema;
}

pub fn render_kernel(writer: *CodeWriter, allocator: std.mem.Allocator, schema: model.Document) !void {
    try render_header(writer);
    _ = allocator;
    _ = schema;
}

pub fn render_stubs(writer: *CodeWriter, allocator: std.mem.Allocator, schema: model.Document) !void {
    _ = writer;
    _ = allocator;
    _ = schema;
}

const ZigRenderer = struct {
    const Error = CodeWriter.Error;

    const fmt_id = std.zig.fmtId;
    const fmt_escapes = std.zig.fmtEscapes;

    writer: *CodeWriter,
    allocator: std.mem.Allocator,
    schema: *const model.Document,

    fn render_children(zr: *ZigRenderer, children: []const model.Declaration) Error!void {
        for (children, 0..) |child, index| {
            const is_first = (index == 0);

            if (!is_first) {
                try zr.writer.writeln("");
            }

            try zr.render_docs(child.docs);

            switch (child.data) {
                .namespace => {
                    try zr.writer.println("pub const {} = struct {{", .{fmt_id(model.local_name(child.full_qualified_name))});

                    {
                        zr.writer.indent();
                        defer zr.writer.dedent();

                        try zr.render_children(child.children);
                    }

                    try zr.writer.writeln("};");
                },
                .@"struct" => |idx| try zr.render_struct_or_union(zr.schema.structs[@intFromEnum(idx)], child.children, .@"struct"),
                .@"union" => |idx| try zr.render_struct_or_union(zr.schema.unions[@intFromEnum(idx)], child.children, .@"union"),

                .@"enum" => std.log.err("rendering enum is not implemented yet!", .{}),
                .bitstruct => std.log.err("rendering bitstruct is not implemented yet!", .{}),
                .syscall => std.log.err("rendering syscall is not implemented yet!", .{}),
                .async_call => std.log.err("rendering async_call is not implemented yet!", .{}),
                .resource => std.log.err("rendering resource is not implemented yet!", .{}),
                .constant => std.log.err("rendering constant is not implemented yet!", .{}),
                .typedef => std.log.err("rendering typedef is not implemented yet!", .{}),
            }
        }
    }

    fn render_struct_or_union(zr: *ZigRenderer, container: model.Struct, children: []const model.Declaration, container_type: enum { @"struct", @"union" }) !void {
        try zr.writer.println("pub const {} = {s} {{", .{
            fmt_id(model.local_name(container.full_qualified_name)),
            @tagName(container_type),
        });

        {
            zr.writer.indent();
            defer zr.writer.dedent();

            for (container.fields) |field| {
                try zr.render_docs(field.docs);
                try zr.writer.print("{}: {}", .{ fmt_id(field.name), zr.fmt_type(field.type) });
                if (field.default) |default| {
                    try zr.writer.print(" = {}", .{zr.fmt_value(default)});
                }
                try zr.writer.writeln(",");
            }

            try zr.render_children(children);
        }

        try zr.writer.writeln("};");
    }

    fn render_docs(zr: *ZigRenderer, docs: model.DocString) !void {
        for (docs) |line| {
            try zr.writer.println("/// {s}", .{line});
        }
    }

    fn fmt_type(zr: *ZigRenderer, type_id: model.TypeIndex) std.fmt.Formatter(format_type) {
        return .{ .data = .{ zr, type_id } };
    }

    fn format_type(pack: struct { *ZigRenderer, model.TypeIndex }, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;

        const zr: *ZigRenderer, const type_id: model.TypeIndex = pack;

        const type_val = zr.schema.types[@intFromEnum(type_id)];

        switch (type_val) {
            .alias => |child| try writer.print("{}", .{zr.fmt_type(child)}),

            .well_known => |id| try writer.writeAll(switch (id) {
                .void => "void",
                .bool => "bool",
                .noreturn => "noreturn",
                .anyptr => "*anyopaque",
                .anyfnptr => "*anyopaque", // TODO?
                .str => "[]const u8",
                .bytestr => "[]const u8",
                .bytebuf => "[]u8",
                .u8 => "u8",
                .u16 => "u16",
                .u32 => "u32",
                .u64 => "u64",
                .usize => "usize",
                .i8 => "i8",
                .i16 => "i16",
                .i32 => "i32",
                .i64 => "i64",
                .isize => "isize",
                .f32 => "f32",
                .f64 => "f64",
            }),

            .optional => |child| try writer.print("?{}", .{zr.fmt_type(child)}),

            .array => |arr| try writer.print("[{}]{}", .{ arr.size, zr.fmt_type(arr.child) }),

            .ptr => |ptr| {
                try writer.writeAll(switch (ptr.size) {
                    .one => "*",
                    .slice => "[]",
                    .unknown => "[*]",
                });

                if (ptr.is_const) {
                    try writer.writeAll("const ");
                }
                if (ptr.alignment) |alignment| {
                    try writer.print("align({}) ", .{alignment});
                }

                try writer.print("{}", .{zr.fmt_type(ptr.child)});
            },

            .@"enum" => |index| try writer.print("{}", .{
                fmt_fqn(zr.schema.enums[@intFromEnum(index)].full_qualified_name),
            }),

            .@"struct" => |index| try writer.print("{}", .{
                fmt_fqn(zr.schema.structs[@intFromEnum(index)].full_qualified_name),
            }),

            .@"union" => |index| try writer.print("{}", .{
                fmt_fqn(zr.schema.unions[@intFromEnum(index)].full_qualified_name),
            }),

            .bitstruct => |index| try writer.print("{}", .{
                fmt_fqn(zr.schema.bitstructs[@intFromEnum(index)].full_qualified_name),
            }),

            .resource => |index| try writer.print("{}", .{
                fmt_fqn(zr.schema.resources[@intFromEnum(index)].full_qualified_name),
            }),

            .typedef => |typedef| try writer.print("{}", .{
                fmt_fqn(typedef.full_qualified_name),
            }),

            else => try writer.print("<<{s}>>", .{@tagName(type_val)}),
        }
    }

    fn fmt_value(zr: *ZigRenderer, value: model.Value) std.fmt.Formatter(format_value) {
        return .{ .data = .{ zr, value } };
    }

    fn format_value(pack: struct { *ZigRenderer, model.Value }, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        const zr: *ZigRenderer, const value: model.Value = pack;

        _ = fmt;
        _ = zr;
        _ = options;
        _ = value;

        try writer.writeAll("<<value>>");
    }
};

fn fmt_fqn(fqn: []const []const u8) std.fmt.Formatter(format_fqn) {
    return .{ .data = fqn };
}

fn format_fqn(fqn: []const []const u8, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
    _ = fmt;
    _ = options;
    for (fqn, 0..) |name, i| {
        if (i > 0)
            try writer.writeAll(".");
        try writer.writeAll(name);
    }
}
