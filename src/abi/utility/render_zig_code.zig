const std = @import("std");
const abi_parser = @import("abi-parser");

const code_writer = @import("code_writer.zig");

const model = abi_parser.model;

const Mode = enum { userland, kernel, definition, stubs };

const CodeWriter = code_writer.CodeWriter(std.fs.File.Writer);

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    const allocator = arena.allocator();

    const argv = try std.process.argsAlloc(allocator);

    if (argv.len != 4)
        @panic("<exe> <mode> <input> <output>");

    const mode: Mode = std.meta.stringToEnum(Mode, argv[1]) orelse return error.InvalidMode;

    const json_txt = try std.fs.cwd().readFileAlloc(allocator, argv[2], 1 << 30);

    const schema = try model.from_json_str(allocator, json_txt);

    var output = try std.fs.cwd().atomicFile(argv[3], .{});
    defer output.deinit();

    var writer: CodeWriter = .init(output.file.writer());

    const document = schema.value;
    switch (mode) {
        .userland => try render_userland(&writer, allocator, document),
        .kernel => try render_kernel(&writer, allocator, document),
        .definition => try render_definition(&writer, allocator, document),
        .stubs => try render_stubs(&writer, allocator, document),
    }

    try writer.flush();

    try output.finish();
}

fn render_header(writer: *CodeWriter) !void {
    try writer.writeln(
        \\//!
        \\//! THIS CODE WAS AUTOGENERATED!
        \\//!
        \\
        \\
    );
}

pub fn render_definition(writer: *CodeWriter, allocator: std.mem.Allocator, schema: model.Document) !void {
    try render_header(writer);

    var renderer: ZigRenderer = .{
        .allocator = allocator,
        .writer = writer,
        .schema = &schema,
    };

    try renderer.render_children(schema.root);
}

pub fn render_userland(writer: *CodeWriter, allocator: std.mem.Allocator, schema: model.Document) !void {
    try render_header(writer);
    _ = allocator;
    _ = schema;
}

pub fn render_kernel(writer: *CodeWriter, allocator: std.mem.Allocator, schema: model.Document) !void {
    try render_header(writer);
    _ = allocator;
    _ = schema;
}

pub fn render_stubs(writer: *CodeWriter, allocator: std.mem.Allocator, schema: model.Document) !void {
    _ = writer;
    _ = allocator;
    _ = schema;
}

const ZigRenderer = struct {
    const Error = CodeWriter.Error;

    const fmt_id = std.zig.fmtId;
    const fmt_escapes = std.zig.fmtEscapes;

    writer: *CodeWriter,
    allocator: std.mem.Allocator,
    schema: *const model.Document,

    fn render_children(zr: *ZigRenderer, children: []const model.Declaration) Error!void {
        for (children, 0..) |child, index| {
            const is_first = (index == 0);

            if (!is_first) {
                try zr.writer.writeln("");
            }

            try zr.render_docs(child.docs);

            switch (child.data) {
                .namespace => {
                    try zr.writer.println("pub const {} = struct {{", .{fmt_id(model.local_name(child.full_qualified_name))});

                    {
                        zr.writer.indent();
                        defer zr.writer.dedent();

                        try zr.render_children(child.children);
                    }

                    try zr.writer.writeln("};");
                },
                .@"struct" => |idx| try zr.render_struct_or_union(zr.schema.get_struct(idx), child.children, .@"struct"),
                .@"union" => |idx| try zr.render_struct_or_union(zr.schema.get_union(idx), child.children, .@"union"),
                .@"enum" => |idx| try zr.render_enum(zr.schema.get_enum(idx), child.children),
                .bitstruct => |idx| try zr.render_bitstruct(zr.schema.get_bitstruct(idx), child.children),

                .resource => |idx| try zr.render_resource(zr.schema.get_resource(idx), child.children),
                .constant => |idx| try zr.render_constant(zr.schema.get_constant(idx), child.children),
                .typedef => |idx| try zr.render_typedef(zr.schema.get_type(idx).typedef, child.children),

                .syscall => |idx| try zr.render_syscall(zr.schema.get_syscall(idx), child.children),
                .async_call => |idx| try zr.render_async_call(zr.schema.get_async_call(idx), child.children),
            }
        }
    }

    fn render_syscall(zr: *ZigRenderer, syscall: *const model.GenericCall, children: []const model.Declaration) !void {
        std.debug.assert(children.len == 0);

        try zr.writer.println("pub extern fn {}(", .{
            fmt_id(model.local_name(syscall.full_qualified_name)),
        });

        {
            zr.writer.indent();
            defer zr.writer.dedent();

            for (syscall.native_inputs) |input| {
                try zr.render_docs(input.docs);
                try zr.writer.print("{}: {},", .{
                    fmt_id(input.name),
                    zr.fmt_type(input.type),
                });
                if (input.default) |default| {
                    try zr.writer.print(" // = {}", .{zr.fmt_value(default)});
                }
                try zr.writer.writeln("");
            }
        }
        try zr.writer.write(") void");

        try zr.writer.writeln(";");
    }

    fn render_async_call(zr: *ZigRenderer, arc: *const model.GenericCall, children: []const model.Declaration) !void {
        try zr.writer.println("pub const {} = extern struct {{", .{
            fmt_id(model.local_name(arc.full_qualified_name)),
        });

        {
            zr.writer.indent();
            defer zr.writer.dedent();
            try zr.writer.writeln("");
            try zr.writer.writeln("pub const Inputs = extern struct {");
            for (arc.native_inputs) |field| {
                zr.writer.indent();
                defer zr.writer.dedent();
                try zr.render_docs(field.docs);
                try zr.writer.print("{}: {}", .{
                    fmt_id(field.name),
                    zr.fmt_type(field.type),
                });
                if (field.default) |default| {
                    try zr.writer.print(" = {}", .{zr.fmt_value(default)});
                }
                try zr.writer.writeln(",");
            }
            try zr.writer.writeln("};");
            try zr.writer.writeln("");

            try zr.writer.writeln("pub const Outputs = extern struct {");
            for (arc.native_outputs) |field| {
                zr.writer.indent();
                defer zr.writer.dedent();
                try zr.render_docs(field.docs);
                try zr.writer.print("{}: {}", .{
                    fmt_id(field.name),
                    zr.fmt_type(field.type),
                });
                if (field.default) |default| {
                    try zr.writer.print(" = {}", .{zr.fmt_value(default)});
                }
                try zr.writer.writeln(",");
            }
            try zr.writer.writeln("};");
            try zr.writer.writeln("");

            try zr.writer.writeln("pub const Error = enum(u16) {");
            try zr.writer.writeln("    success = 0,");
            try zr.writer.writeln("};");

            try zr.writer.writeln("arc: overlapped.ARC,");
            try zr.writer.writeln("inputs: Inputs,");
            try zr.writer.writeln("outputs: Outputs,");
            try zr.writer.writeln("@\"error\": Error,");
            try zr.writer.writeln("");

            try zr.writer.write("pub fn init(");

            for (arc.logic_inputs, 0..) |field, i| {
                if (i > 0)
                    try zr.writer.write(", ");
                try zr.writer.print("{}: {}", .{
                    fmt_id(field.name),
                    zr.fmt_type(field.type),
                });
            }

            try zr.writer.writeln(") @This() {");
            {
                zr.writer.indent();
                defer zr.writer.dedent();
                try zr.writer.writeln("return .{");

                try zr.writer.println("    .arc = .{{ .type = .{_}, .tag = 0 }},", .{
                    fmt_fqn(arc.full_qualified_name),
                });
                try zr.writer.writeln("    .inputs = .{");
                for (arc.native_inputs) |field| {
                    try zr.writer.println("        .{[0]} = {[0]},", .{
                        fmt_id(field.name),
                    });
                }
                try zr.writer.writeln("    },");
                try zr.writer.writeln("    .outputs = undefined,");
                try zr.writer.writeln("    .@\"error\" = .success,");
                try zr.writer.writeln("};");
            }
            try zr.writer.writeln("}");

            try zr.render_children(children);
        }

        try zr.writer.writeln("};");
    }

    fn render_struct_or_union(zr: *ZigRenderer, container: *const model.Struct, children: []const model.Declaration, container_type: enum { @"struct", @"union" }) !void {
        try zr.writer.println("pub const {} = extern {s} {{", .{
            fmt_id(model.local_name(container.full_qualified_name)),
            @tagName(container_type),
        });

        {
            zr.writer.indent();
            defer zr.writer.dedent();

            for (container.native_fields) |field| {
                try zr.render_docs(field.docs);
                try zr.writer.print("{}: {}", .{ fmt_id(field.name), zr.fmt_type(field.type) });
                if (field.default) |default| {
                    try zr.writer.print(" = {}", .{zr.fmt_value(default)});
                }
                try zr.writer.writeln(",");
            }

            try zr.render_children(children);
        }

        try zr.writer.writeln("};");
    }

    fn render_bitstruct(zr: *ZigRenderer, container: *const model.BitStruct, children: []const model.Declaration) !void {
        try zr.writer.println("pub const {} = packed struct({s}) {{", .{
            fmt_id(model.local_name(container.full_qualified_name)),
            @tagName(container.backing_type),
        });

        {
            zr.writer.indent();
            defer zr.writer.dedent();

            var reserved_idx: usize = 0;
            for (container.fields) |field| {
                var reserved_buf: [32]u8 = undefined;
                const reserved_id = try std.fmt.bufPrint(&reserved_buf, "_reserved{}", .{reserved_idx});

                try zr.render_docs(field.docs);
                try zr.writer.print("{}: {}", .{ fmt_id(field.name orelse reserved_id), zr.fmt_type(field.type) });
                if (field.default) |default| {
                    try zr.writer.print(" = {}", .{zr.fmt_value(default)});
                }
                try zr.writer.writeln(",");

                if (field.name == null) {
                    reserved_idx += 1;
                }
            }

            try zr.render_children(children);
        }

        try zr.writer.writeln("};");
    }

    fn render_enum(zr: *ZigRenderer, container: *const model.Enumeration, children: []const model.Declaration) !void {
        try zr.writer.println("pub const {} = enum({s}) {{", .{
            fmt_id(model.local_name(container.full_qualified_name)),
            @tagName(container.backing_type),
        });

        {
            zr.writer.indent();
            defer zr.writer.dedent();

            for (container.items) |item| {
                try zr.render_docs(item.docs);
                try zr.writer.println("{} = {},", .{ fmt_id(item.name), item.value });
            }

            switch (container.kind) {
                .closed => {},
                .open => try zr.writer.writeln("_,"),
            }

            try zr.render_children(children);
        }

        try zr.writer.writeln("};");
    }

    fn render_resource(zr: *ZigRenderer, container: *const model.Resource, children: []const model.Declaration) !void {
        try zr.writer.println("pub const {} = enum(usize) {{", .{
            fmt_id(model.local_name(container.full_qualified_name)),
        });

        {
            zr.writer.indent();
            defer zr.writer.dedent();

            try zr.writer.writeln("_,");

            try zr.render_children(children);
        }

        try zr.writer.writeln("};");
    }

    fn render_constant(zr: *ZigRenderer, container: *const model.Constant, children: []const model.Declaration) !void {
        std.debug.assert(children.len == 0);

        try zr.writer.print("pub const {}", .{
            fmt_id(model.local_name(container.full_qualified_name)),
        });

        if (container.type) |ctype| {
            try zr.writer.print(": {}", .{zr.fmt_type(ctype)});
        }

        try zr.writer.println("= {};", .{zr.fmt_value(container.value)});
    }

    fn render_typedef(zr: *ZigRenderer, container: model.TypeDefition, children: []const model.Declaration) !void {
        std.debug.assert(children.len == 0);

        try zr.writer.println("pub const {} = {};", .{
            fmt_id(model.local_name(container.full_qualified_name)),
            zr.fmt_type(container.alias),
        });
    }

    fn render_docs(zr: *ZigRenderer, docs: model.DocString) !void {
        for (docs) |line| {
            try zr.writer.println("/// {s}", .{line});
        }
    }

    fn fmt_type(zr: *ZigRenderer, type_id: model.TypeIndex) std.fmt.Formatter(format_type) {
        return .{ .data = .{ zr, type_id } };
    }

    fn format_type(pack: struct { *ZigRenderer, model.TypeIndex }, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;

        const zr: *ZigRenderer, const type_id: model.TypeIndex = pack;

        const type_val = zr.schema.get_type(type_id);

        switch (type_val.*) {
            .alias => |child| try writer.print("{}", .{zr.fmt_type(child)}),

            .well_known => |id| try writer.writeAll(switch (id) {
                .void => "void",
                .bool => "bool",
                .noreturn => "noreturn",
                .anyptr => "*anyopaque",
                .anyfnptr => "*anyopaque", // TODO?
                .str => "[]const u8",
                .bytestr => "[]const u8",
                .bytebuf => "[]u8",
                .u8 => "u8",
                .u16 => "u16",
                .u32 => "u32",
                .u64 => "u64",
                .usize => "usize",
                .i8 => "i8",
                .i16 => "i16",
                .i32 => "i32",
                .i64 => "i64",
                .isize => "isize",
                .f32 => "f32",
                .f64 => "f64",
            }),

            .optional => |child| try writer.print("?{}", .{zr.fmt_type(child)}),

            .array => |arr| try writer.print("[{}]{}", .{ arr.size, zr.fmt_type(arr.child) }),

            .ptr => |ptr| {
                try writer.writeAll(switch (ptr.size) {
                    .one => "*",
                    .slice => "[]",
                    .unknown => "[*]",
                });

                if (ptr.is_const) {
                    try writer.writeAll("const ");
                }
                if (ptr.alignment) |alignment| {
                    try writer.print("align({}) ", .{alignment});
                }

                try writer.print("{}", .{zr.fmt_type(ptr.child)});
            },

            .@"enum" => |index| try writer.print("{}", .{
                fmt_fqn(zr.schema.get_enum(index).full_qualified_name),
            }),

            .@"struct" => |index| try writer.print("{}", .{
                fmt_fqn(zr.schema.get_struct(index).full_qualified_name),
            }),

            .@"union" => |index| try writer.print("{}", .{
                fmt_fqn(zr.schema.get_union(index).full_qualified_name),
            }),

            .bitstruct => |index| try writer.print("{}", .{
                fmt_fqn(zr.schema.get_bitstruct(index).full_qualified_name),
            }),

            .resource => |index| try writer.print("{}", .{
                fmt_fqn(zr.schema.get_resource(index).full_qualified_name),
            }),

            .typedef => |typedef| try writer.print("{}", .{
                fmt_fqn(typedef.full_qualified_name),
            }),

            .uint => |size| try writer.print("u{}", .{size}),
            .int => |size| try writer.print("i{}", .{size}),

            .fnptr, .external => try writer.print("<<{s}>>", .{@tagName(type_val.*)}),

            .unknown_named_type, .unset_magic_type => @panic("invalid model"),
        }
    }

    fn fmt_value(zr: *ZigRenderer, value: model.Value) std.fmt.Formatter(format_value) {
        return .{ .data = .{ zr, value } };
    }

    fn format_value(pack: struct { *ZigRenderer, model.Value }, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        const zr: *ZigRenderer, const value: model.Value = pack;

        _ = fmt;
        _ = zr;
        _ = options;

        switch (value) {
            .null => try writer.writeAll("null"),

            .bool => |b| try writer.print("{}", .{b}),

            .string => |str| try writer.print("\"{}\"", .{fmt_escapes(str)}),

            .int => |i| try writer.print("{}", .{i}),

            .compound => try writer.print("<<{s}>>", .{@tagName(value)}),
        }
    }
};

fn fmt_fqn(fqn: []const []const u8) std.fmt.Formatter(format_fqn) {
    return .{ .data = fqn };
}

fn format_fqn(fqn: []const []const u8, fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
    _ = options;
    for (fqn, 0..) |name, i| {
        if (i > 0) {
            try writer.writeAll(if (fmt.len > 0) fmt else ".");
        }
        try writer.writeAll(name);
    }
}
