const syscalls = struct {
    extern "syscall" fn no_operation() void;

    extern "syscall" fn arg_with_name(v: u32) u32;
    extern "syscall" fn arg_without_name(u32) u32;

    extern "syscall" fn regular_slice(slice: []const u8) u32;

    extern "syscall" fn optional_slice(slice: ?[]const u8) u32;

    extern "syscall" fn out_slice(index: u32, out: *[]const u8) void;

    extern "syscall" fn out_optional_slice(index: u32, out: *?[]const u8) void;

    extern "syscall" fn return_plain_error(index: u32) error{ One, Two };

    const slice_asserts = struct {
        extern "syscall" fn basic([]const u8) void;
        extern "syscall" fn optional(?[]const u8) void;
        extern "syscall" fn out_basic(*[]const u8) void;
        extern "syscall" fn out_optional(*?[]const u8) void;
        extern "syscall" fn inout_basic(*[]const u8) void;
        extern "syscall" fn inout_optional(*?[]const u8) void;
    };
};

const io = struct {
    extern "iop" fn NoOperation() error{}!void;
};

pub const Src1 = struct(SystemResource) {};
pub const Src2 = struct(SystemResource) {};

usingnamespace zig; // regular code beyond this

// pass this verbatim!

pub const SystemResource = struct {};

pub const IOP = struct {
    pub fn define(v: anytype) @TypeOf(v) {
        return v;
    }
};

pub fn ErrorSet(comptime et: type) type {
    _ = et;
    return enum(u32) {
        ok = 0,
        One = 1,
        Two = 2,
    };
}
