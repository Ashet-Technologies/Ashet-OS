const std = @import("std");
const ashet = @import("ashet");
const TextEditor = @import("text-editor");

const Point = ashet.abi.Point;
const Size = ashet.abi.Size;
const Rectangle = ashet.abi.Rectangle;
const ColorIndex = ashet.abi.ColorIndex;

/// An event that can be passed to widgets.
/// Each event carries information about what happends (`id`) and
/// potentially additional pointer information (`tag`).
pub const Event = struct {
    id: EventID,
    tag: ?*anyopaque,

    pub fn get(comptime name: []const u8) Event {
        return Event{ .id = EventID.get(name), .tag = null };
    }

    pub fn getTagged(comptime name: []const u8, tag: ?*anyopaque) Event {
        return Event{ .id = EventID.get(name), .tag = tag };
    }
};

/// A unique event id. A unique tag can be generated by using the `get()`
/// function with a string. Each string generates a unique variant.
/// EventIDs can also be generated by casting `usize` values into the event.
pub const EventID = enum(usize) {
    _,

    pub fn get(comptime name: []const u8) Event {
        return innerGet(name.len, name[0..name.len].*);
    }

    fn innerGet(comptime len: usize, id: [len]u8) Event {
        const T = struct { tag: u8 };
        _ = id;
        return @intToEnum(Event, @ptrToInt(&T.tag));
    }
};

pub const Framebuffer = @import("Framebuffer.zig");
pub const Bitmap = @import("Bitmap.zig");

pub const Theme = struct {
    area: ColorIndex, // filling for panels, buttons, text boxes, ...
    area_light: ColorIndex, // a brighter version of `area`
    area_shadow: ColorIndex, // a darker version of `area`

    label: ColorIndex, // the text of a label
    text: ColorIndex, // the text of a button, text box, ...

    pub const default = Theme{
        .area = ColorIndex.get(7),
        .area_light = ColorIndex.get(10),
        .area_shadow = ColorIndex.get(3),
        .label = ColorIndex.get(15),
        .text = ColorIndex.get(0),
    };
};

pub const Interface = struct {
    /// List of widgets, bottom to top
    widgets: []Widget,
    theme: *const Theme = &Theme.default,

    pub fn widgetFromPoint(gui: *Interface, pt: Point) ?*Widget {
        var i: usize = gui.widgets.len;
        while (i > 0) {
            i -= 1;
            const widget = &gui.widgets[i];
            if (widget.bounds.contains(pt))
                return widget;
        }
        return null;
    }

    pub fn sendMouseEvent(gui: *Interface, event: ashet.abi.MouseEvent) ?Event {
        switch (event.type) {
            .button_press => if (event.button == .left) {
                if (gui.widgetFromPoint(Point.new(event.x, event.y))) |widget| {
                    switch (widget.control) {
                        .button => |btn| return btn.clickEvent,
                        .text_box => @panic("not implemented yet!"),
                        .label, .panel, .picture => {},
                    }
                }
            },
            .button_release => {},
            .motion => {},
        }

        return null;
    }

    pub fn sendKeyboardEvent(gui: *Interface, event: ashet.abi.KeyboardEvent) ?Event {
        _ = gui;
        _ = event;
        return null;
    }

    pub fn paint(gui: Interface, target: Framebuffer) void {
        for (gui.widgets) |widget| {
            switch (widget.control) {
                .button => |ctrl| {
                    _ = ctrl;
                    target.fillRectangle(widget.bounds.shrink(1), gui.theme.area);
                    target.drawRectangle(widget.bounds, gui.theme.area_light);
                },
                .label => |ctrl| {
                    _ = ctrl;
                },
                .text_box => |ctrl| {
                    _ = ctrl;
                },
                .panel => |ctrl| {
                    _ = ctrl;
                },
                .picture => |ctrl| {
                    _ = ctrl;
                },
            }
        }
    }
};

pub const Widget = struct {
    bounds: Rectangle,
    control: Control,
};

pub const Control = union(enum) {
    button: Button,
    label: Label,
    text_box: TextBox,
    panel: Panel,
    picture: Picture,
};

pub const Button = struct {
    clickEvent: ?Event = null,
    text: []const u8,

    pub fn new(x: i16, y: i16, width: ?u15, text: []const u8) Widget {
        return Widget{
            .bounds = Rectangle{
                .x = x,
                .y = y,
                .width = width orelse @intCast(u15, text.len * 6),
                .height = 11,
            },
            .control = .{
                .button = Button{
                    .clickEvent = null,
                    .text = text,
                },
            },
        };
    }
};

pub const Label = struct {
    pub fn new(x: i16, y: i16, text: []const u8) Widget {
        _ = x;
        _ = y;
        _ = text;
    }
};

pub const TextBox = struct {
    pub fn new(x: i16, y: i16, width: u15, text: []const u8) Widget {
        //
        _ = x;
        _ = y;
        _ = width;
        _ = text;
    }
};

pub const Panel = struct {
    pub fn new(x: i16, y: i16, width: u15, height: u15) Widget {
        //
        _ = x;
        _ = y;
        _ = width;
        _ = height;
    }
};

pub const Picture = struct {
    bitmap: Bitmap,
    pub fn new(x: i16, y: i16, bitmap: Bitmap) Widget {
        //
        _ = x;
        _ = y;
        _ = bitmap;
    }
};
