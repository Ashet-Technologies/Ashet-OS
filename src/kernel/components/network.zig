const std = @import("std");
const abi = ashet.abi;
const ashet = @import("../main.zig");
const astd = @import("ashet-std");
const logger = std.log.scoped(.network);

const c = @cImport({
    @cInclude("lwip/init.h");
    @cInclude("lwip/tcpip.h");
    @cInclude("lwip/netif.h");
    @cInclude("lwip/dhcp.h");
    @cInclude("lwip/tcp.h");
    @cInclude("lwip/udp.h");
    @cInclude("lwip/etharp.h");
    @cInclude("lwip/ethip6.h");
    @cInclude("lwip/timeouts.h");
});

const abi_tcp = ashet.abi.network.tcp;
const abi_udp = ashet.abi.network.udp;

pub const Interface = enum {
    ethernet,
    ieee802_11,

    pub fn prefix(i: Interface) u8 {
        return switch (i) {
            .ethernet => 'E',
            .ieee802_11 => 'W',
        };
    }
};

pub const MAC = struct {
    tuple: [6]u8,
    pub fn init(v: [6]u8) MAC {
        return MAC{ .tuple = v };
    }

    pub fn format(mac: MAC, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;

        try writer.print("{X:0>2}:{X:0>2}:{X:0>2}:{X:0>2}:{X:0>2}:{X:0>2}", .{
            mac.tuple[0],
            mac.tuple[1],
            mac.tuple[2],
            mac.tuple[3],
            mac.tuple[4],
            mac.tuple[5],
        });
    }
};

pub fn appendToPBUF(pbuf: *c.pbuf, data: []const u8) !void {
    const len = std.math.cast(u16, data.len) orelse return error.OutOfMemory;
    try lwipTry(c.pbuf_take(pbuf, data.ptr, len));
}

pub const IncomingPacket = struct {
    pbuf: *c.pbuf,

    pub fn append(packet: IncomingPacket, data: []const u8) !void {
        try appendToPBUF(packet.pbuf, data);
    }
};

pub const NetworkInterface = struct {
    pub const VTable = struct {
        /// Returns `true` if the link is up and a cable is connected.
        linkIsUpFn: *const fn (*ashet.drivers.Driver) bool,

        /// Allocates a network packet from the driver that can be
        /// sent with the `send` function.
        /// Values returned by `allocPacket` are guaranteed to be dispatched
        /// to `send`.
        allocOutgoingPacketFn: *const fn (*ashet.drivers.Driver, size: usize) ?[]u8,

        /// Sends a packet previously allocated with `allocPacket` to
        /// the interface. The function is guaranteed to be called only
        /// with values generated by `allocPacket`.
        sendFn: *const fn (*ashet.drivers.Driver, buffer: []u8) bool,

        /// Polls the NetworkInterface for new incoming packages.
        /// Is called periodically to ensure network liveness.
        pollFn: *const fn (*ashet.drivers.Driver) void,
    };

    interface: Interface,
    address: MAC,
    mtu: u16,

    vtable: *const VTable,

    dhcp: c.dhcp = undefined,
    netif: c.netif = undefined,

    pub fn allocIncomingPacket(nic: *NetworkInterface, size: usize) !IncomingPacket {
        _ = nic;

        const len = std.math.cast(u16, size) orelse return error.PacketTooBig;

        const pbuf: *c.pbuf = c.pbuf_alloc(c.PBUF_RAW, len, c.PBUF_POOL) orelse return error.OutOfMemory;

        return IncomingPacket{ .pbuf = pbuf };
    }

    pub fn freeIncomingPacket(nic: *NetworkInterface, packet: IncomingPacket) void {
        _ = nic;
        _ = c.pbuf_free(packet.pbuf); // return value is irrelevant for us
    }

    pub fn receive(nic: *NetworkInterface, packet: IncomingPacket) void {
        if (nic.netif.input.?(packet.pbuf, &nic.netif) != c.ERR_OK) {
            _ = c.pbuf_free(packet.pbuf); // return value is irrelevant for us
        }
    }

    pub fn getName(nic: *const NetworkInterface) []const u8 {
        return &nic.netif.name;
    }

    fn linkIsUp(nic: *NetworkInterface) bool {
        return nic.vtable.linkIsUpFn(ashet.drivers.resolveDriver(.network, nic));
    }
    fn allocOutgoingPacket(nic: *NetworkInterface, size: usize) ?[]u8 {
        return nic.vtable.allocOutgoingPacketFn(ashet.drivers.resolveDriver(.network, nic), size);
    }
    fn send(nic: *NetworkInterface, buffer: []u8) bool {
        return nic.vtable.sendFn(ashet.drivers.resolveDriver(.network, nic), buffer);
    }
    fn poll(nic: *NetworkInterface) void {
        return nic.vtable.pollFn(ashet.drivers.resolveDriver(.network, nic));
    }
};

const IPFormatter = struct {
    addr: c.ip_addr_t,

    pub fn new(addr: c.ip_addr_t) IPFormatter {
        return IPFormatter{ .addr = addr };
    }

    pub fn format(addr: IPFormatter, comptime fmt: []const u8, opt: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = opt;
        try writer.writeAll(std.mem.sliceTo(c.ip4addr_ntoa(@as(*const c.ip4_addr_t, @ptrCast(&addr.addr))), 0));
    }
};

fn netif_status_callback(netif_c: [*c]c.netif) callconv(.C) void {
    const netif: *c.netif = netif_c;

    logger.info("netif status changed ip to {}", .{IPFormatter.new(netif.ip_addr)});
}

fn netif_init(netif_c: [*c]c.netif) callconv(.C) c.err_t {
    const netif: *c.netif = netif_c;
    const nic: *NetworkInterface = @fieldParentPtr("netif", netif);

    netif.linkoutput = netif_output;
    netif.output = c.etharp_output;
    netif.output_ip6 = c.ethip6_output;
    netif.mtu = nic.mtu; // c.ETHERNET_MTU;
    netif.flags = c.NETIF_FLAG_BROADCAST | c.NETIF_FLAG_ETHARP | c.NETIF_FLAG_ETHERNET | c.NETIF_FLAG_IGMP | c.NETIF_FLAG_MLD6;
    // c.MIB2_INIT_NETIF(netif, c.snmp_ifType_ethernet_csmacd, 100000000);
    std.mem.copyForwards(u8, &netif.hwaddr, &nic.address.tuple);
    netif.hwaddr_len = c.ETH_HWADDR_LEN;
    return c.ERR_OK;
}

fn netif_output(netif_c: [*c]c.netif, pbuf_c: [*c]c.pbuf) callconv(.C) c.err_t {
    const netif: *c.netif = netif_c;
    const pbuf: *c.pbuf = pbuf_c;
    const nic: *NetworkInterface = @fieldParentPtr("netif", netif);

    // c.LINK_STATS_INC(lwip_stats.link.xmit);
    // Update SNMP stats (only if you use SNMP)
    // c.MIB2_STATS_NETIF_ADD(netif, ifoutoctets, pbuf.tot_len);
    // const unicast = ((pbuf.payload[0] & 0x01) == 0);
    // if (unicast) {
    //     c.MIB2_STATS_NETIF_INC(netif, ifoutucastpkts);
    // } else {
    //     c.MIB2_STATS_NETIF_INC(netif, ifoutnucastpkts);
    // }

    // TODO: lock_interrupts();

    logger.debug("sending {} bytes via {s}...", .{ pbuf.tot_len, netif.name });

    if (nic.allocOutgoingPacket(pbuf.tot_len)) |packet| {
        // TODO: Handle length here
        var off: usize = 0;
        while (off < pbuf.tot_len) {
            const cnt = c.pbuf_copy_partial(pbuf, packet.ptr + off, @as(u15, @intCast(pbuf.tot_len - off)), @as(u15, @intCast(off)));
            if (cnt == 0) {
                logger.err("failed to copy network packet", .{});
                return c.ERR_BUF;
            }
            off += cnt;
        }
        if (!nic.send(packet)) {
            logger.err("failed to send network packet!", .{});
        }
    } else {
        logger.err("failed to allocate network packet!", .{});
    }

    // TODO: unlock_interrupts();
    return c.ERR_OK;
}

pub fn start() !void {
    c.lwip_init();

    var index: usize = 0;
    var nics = ashet.drivers.enumerate(.network);
    while (nics.next()) |nic| : (index += 1) {
        logger.info("initializing NetworkInterface '{c}{d}' (MAC={})...", .{ nic.interface.prefix(), index, nic.address });

        const netif = &nic.netif;

        _ = c.netif_add(
            netif,
            @as(*c.ip4_addr_t, @ptrCast(@constCast(c.IP4_ADDR_ANY))), // ipaddr
            @as(*c.ip4_addr_t, @ptrCast(@constCast(c.IP4_ADDR_ANY))), // netmask
            @as(*c.ip4_addr_t, @ptrCast(@constCast(c.IP4_ADDR_ANY))), // gw
            null,
            netif_init,
            c.netif_input,
        ) orelse return error.OutOfMemory;

        _ = try std.fmt.bufPrint(&netif.name, "{c}{d}", .{ nic.interface.prefix(), index });

        c.netif_create_ip6_linklocal_address(netif, 1);
        netif.ip6_autoconfig_enabled = 1;
        c.netif_set_status_callback(netif, netif_status_callback);
        c.netif_set_default(netif);

        c.dhcp_set_struct(netif, &nic.dhcp);

        c.netif_set_up(netif);

        try lwipTry(c.dhcp_start(netif));

        c.netif_set_link_up(netif);
    }

    if (index > 0) {
        logger.info("Network adapters found, starting network task...", .{});

        // we found a network adapter, start the backgruond thread
        const network_thread = try ashet.scheduler.Thread.spawn(networkThread, null, .{});
        errdefer network_thread.kill();

        try network_thread.setName("ashet.network");
        try network_thread.start();
        network_thread.detach();
    }
}

pub fn dumpStats() void {
    var nics = ashet.drivers.enumerate(.network);
    while (nics.next()) |nic| {
        logger.info("nic {s}: up={} link={} ip={} netmask={} gateway={} dhcp={}", .{
            nic.netif.name,
            (nic.netif.flags & c.NETIF_FLAG_UP) != 0,
            (nic.netif.flags & c.NETIF_FLAG_LINK_UP) != 0,
            IPFormatter.new(nic.netif.ip_addr),
            IPFormatter.new(nic.netif.netmask),
            IPFormatter.new(nic.netif.gw),
            c.dhcp_supplied_address(&nic.netif) != 0,
        });
    }
}

fn networkThread(_: ?*anyopaque) callconv(.C) u32 {
    while (true) {
        var nics = ashet.drivers.enumerate(.network);
        while (nics.next()) |nic| {
            nic.poll();
        }
        c.sys_check_timeouts();
        ashet.scheduler.yield();
    }
}

// Returns the current time in milliseconds, may be the same as sys_jiffies or at least based on it.
// Don't care for wraparound, this is only used for time diffs. Not implementing this function means
// you cannot use some modules (e.g. TCP timestamps, internal timeouts for NO_SYS==1).
export fn sys_now() u32 {
    return @as(u32, @truncate(@as(u64, @bitCast(ashet.time.milliTimestamp()))));
}

const LwipError = error{
    /// Out of memory error.
    OutOfMemory,
    /// Buffer error.
    BufferError,
    /// Timeout.
    Timeout,
    /// Routing problem.
    Routing,
    /// Operation in progress
    InProgress,
    /// Illegal value.
    IllegalValue,
    /// Operation would block.
    WouldBlock,
    /// Address in use.
    AddressInUse,
    /// Already connecting.
    AlreadyConnecting,
    /// Conn already established.
    AlreadyConnected,
    /// Not connected.
    NotConnected,
    /// Low-level netif error
    LowlevelInterfaceError,
    /// Connection aborted.
    ConnectionAborted,
    /// Connection reset.
    ConnectionReset,
    /// Connection closed.
    ConnectionClosed,
    /// Illegal argument.
    IllegalArgument,

    /// Unexpected error code
    Unexpected,
};

fn lwipErr(err: c.err_t) LwipError {
    if (lwipTry(err)) |_|
        unreachable
    else |e|
        return e;
}

fn lwipTry(err: c.err_t) LwipError!void {
    return switch (err) {
        c.ERR_OK => {},
        c.ERR_MEM => LwipError.OutOfMemory,
        c.ERR_BUF => LwipError.BufferError,
        c.ERR_TIMEOUT => LwipError.Timeout,
        c.ERR_RTE => LwipError.Routing,
        c.ERR_INPROGRESS => LwipError.InProgress,
        c.ERR_VAL => LwipError.IllegalValue,
        c.ERR_WOULDBLOCK => LwipError.WouldBlock,
        c.ERR_USE => LwipError.AddressInUse,
        c.ERR_ALREADY => LwipError.AlreadyConnecting,
        c.ERR_ISCONN => LwipError.AlreadyConnected,
        c.ERR_CONN => LwipError.NotConnected,
        c.ERR_IF => LwipError.LowlevelInterfaceError,
        c.ERR_ABRT => LwipError.ConnectionAborted,
        c.ERR_RST => LwipError.ConnectionReset,
        c.ERR_CLSD => LwipError.ConnectionClosed,
        c.ERR_ARG => LwipError.IllegalArgument,
        else => LwipError.Unexpected,
    };
}

const LWIP_Error_Code = enum(c.err_t) {
    mem = c.ERR_MEM,
    buf = c.ERR_BUF,
    timeout = c.ERR_TIMEOUT,
    rte = c.ERR_RTE,
    inprogress = c.ERR_INPROGRESS,
    val = c.ERR_VAL,
    wouldblock = c.ERR_WOULDBLOCK,
    use = c.ERR_USE,
    already = c.ERR_ALREADY,
    isconn = c.ERR_ISCONN,
    conn = c.ERR_CONN,
    interface = c.ERR_IF,
    abrt = c.ERR_ABRT,
    rst = c.ERR_RST,
    clsd = c.ERR_CLSD,
    arg = c.ERR_ARG,

    fn to_zig_error(code: LWIP_Error_Code) LwipError {
        std.debug.assert(@intFromEnum(code) != c.ERR_OK);
        return switch (code) {
            .mem => LwipError.OutOfMemory,
            .buf => LwipError.BufferError,
            .timeout => LwipError.Timeout,
            .rte => LwipError.Routing,
            .inprogress => LwipError.InProgress,
            .val => LwipError.IllegalValue,
            .wouldblock => LwipError.WouldBlock,
            .use => LwipError.AddressInUse,
            .already => LwipError.AlreadyConnecting,
            .isconn => LwipError.AlreadyConnected,
            .conn => LwipError.NotConnected,
            .interface => LwipError.LowlevelInterfaceError,
            .abrt => LwipError.ConnectionAborted,
            .rst => LwipError.ConnectionReset,
            .clsd => LwipError.ConnectionClosed,
            .arg => LwipError.IllegalArgument,
        };
    }
};

fn wrap_lwip_call(comptime func: anytype, comptime error_set: []const LWIP_Error_Code) type {
    const F = @TypeOf(func);
    const fnInfo = @typeInfo(F).Fn;

    std.debug.assert(fnInfo.return_type == c.err_t);

    var arg_fields: [fnInfo.params.len]std.builtin.Type.StructField = undefined;
    for (&arg_fields, fnInfo.params, 0..) |*out, in, i| {
        out.* = .{
            .name = std.fmt.comptimePrint("{d}", .{i}),
            .type = in.type.?,
            .alignment = @alignOf(in.type.?),
            .default_value = null,
            .is_comptime = false,
        };
    }

    var errors: [error_set.len]std.builtin.Type.Error = undefined;
    for (&errors, error_set) |*out, in| {
        out.* = .{ .name = @errorName(in.to_zig_error()) };
    }

    const E = @Type(.{ .ErrorSet = &errors });

    const Tuple = @Type(.{ .Struct = .{
        .layout = .auto,
        .is_tuple = true,
        .decls = &.{},
        .fields = &arg_fields,
    } });

    return struct {
        fn invoke_tuple(args: Tuple) E!void {
            const return_code: c.err_t = @call(.auto, func, args);
            if (return_code == c.ERR_OK)
                return;
            inline for (error_set) |err| {
                if (return_code == @intFromEnum(err))
                    return @field(anyerror, @errorName(err.to_zig_error()));
            }
            std.log.err("{} returned unexpected error code {}", .{ &func, return_code });
            @panic("unexpected return value from LWIP!");
        }

        const invoke = astd.mpl.reify_function(invoke_tuple);
    };
}

// TODO(fqu): Search lwIP sources to see what errors each function can return:
const lwip = struct {
    const pbuf = struct {
        const take = wrap_lwip_call(c.pbuf_take, &.{.mem}).invoke;
    };

    const dhcp = struct {
        const start = wrap_lwip_call(c.dhcp_start, &.{}).invoke;
    };

    const tcp = struct {
        const bind = wrap_lwip_call(c.tcp_bind, &.{
            // ERR_OK if bound
            .use, // ERR_USE if the port is already in use
            .val, // ERR_VAL if bind failed because the PCB is not in a valid state
        }).invoke;
        const connect = wrap_lwip_call(c.tcp_connect, &.{
            .val, //ERR_VAL if invalid arguments are given
            // ERR_OK if connect request has been sent
            // other err_t values if connect request couldn't be sent
        }).invoke;
        const write = wrap_lwip_call(c.tcp_write, &.{.mem}).invoke;
    };
    const udp = struct {
        const bind = wrap_lwip_call(c.udp_bind, &.{}).invoke;
        const connect = wrap_lwip_call(c.udp_connect, &.{}).invoke;
        const send = wrap_lwip_call(c.udp_send, &.{}).invoke;
        const sendto = wrap_lwip_call(c.udp_sendto, &.{}).invoke;
    };
};

pub const EndPoint = abi.EndPoint;
pub const IP = abi.IP;

fn mapIP(ip: IP) c.ip_addr_t {
    return switch (ip.type) {
        .ipv4 => c.ip_addr_t{
            .type = c.IPADDR_TYPE_V4,
            .u_addr = .{ .ip4 = .{ .addr = @as(u32, @bitCast(ip.addr.v4.addr)) } },
        },
        .ipv6 => c.ip_addr_t{
            .type = c.IPADDR_TYPE_V6,
            .u_addr = .{ .ip6 = .{ .addr = @as([4]u32, @bitCast(ip.addr.v6.addr)), .zone = ip.addr.v6.zone } },
        },
    };
}

fn unmapIP(addr: c.ip_addr_t) IP {
    return switch (addr.type) {
        c.IPADDR_TYPE_V4 => IP{
            .type = .ipv4,
            .addr = .{ .v4 = .{ .addr = @as([4]u8, @bitCast(addr.u_addr.ip4.addr)) } },
        },
        c.IPADDR_TYPE_V6 => IP{
            .type = .ipv6,
            .addr = .{ .v6 = .{ .addr = @as([16]u8, @bitCast(addr.u_addr.ip6.addr)), .zone = addr.u_addr.ip6.zone } },
        },
        else => unreachable,
    };
}

fn limitLength(val: usize) u16 {
    @setRuntimeSafety(false);
    return @as(u16, @intCast(@min(val, std.math.maxInt(u16))));
}

pub const udp = struct {
    const max_sockets = @as(usize, @intCast(c.MEMP_NUM_UDP_PCB));

    pub const Socket = struct {
        system_resource: ashet.resources.SystemResource = .{ .type = .udp_socket },

        pub fn destroy(sock: *Socket) void {
            _ = sock;
            @panic("Not implemented yet!");
        }
    };

    const Data = struct {
        receive_iop: ?*abi_udp.ReceiveFrom = null,
    };

    var pool: astd.IndexPool(u32, max_sockets) = .{};
    var sockets: [max_sockets]*c.udp_pcb = undefined;
    var socket_meta: [max_sockets]Data = undefined;

    fn unmap(sock: Socket) error{InvalidHandle}!*c.udp_pcb {
        if (sock == .invalid)
            return error.InvalidHandle;
        const index = @intFromEnum(sock);
        if (index >= max_sockets)
            return error.InvalidHandle;
        if (!pool.alive(index))
            return error.InvalidHandle;
        return sockets[index];
    }

    pub fn createSocket() !Socket {
        const index = pool.alloc() orelse return error.SystemResources;
        errdefer pool.free(index);

        const pcb = c.udp_new() orelse return error.SystemResources;
        sockets[index] = pcb;

        socket_meta[index] = Data{};

        c.udp_recv(pcb, handleIncomingPacket, &socket_meta[index]);

        return @as(Socket, @enumFromInt(index));
    }

    fn handleIncomingPacket(arg: ?*anyopaque, pcb_c: [*c]c.udp_pcb, pbuf_c: [*c]c.pbuf, addr_c: [*c]const c.ip_addr_t, port: u16) callconv(.C) void {
        const data: *Data = @ptrCast(@alignCast(arg));
        const pcb: *c.udp_pcb = pcb_c;
        const pbuf: *c.pbuf = pbuf_c;
        const addr: *const c.ip_addr_t = addr_c;

        _ = pcb;

        const iop = data.receive_iop orelse {
            logger.err("failed to queue received pbuf. dropping packet of {} bytes.", .{pbuf.tot_len});
            _ = c.pbuf_free(pbuf);
            return;
        };

        const limited_len = @as(u16, @truncate(@min(pbuf.tot_len, iop.inputs.buffer_len)));

        const copied = c.pbuf_copy_partial(pbuf, iop.inputs.buffer_ptr, limited_len, 0);
        std.debug.assert(limited_len == copied);
        _ = c.pbuf_free(pbuf);

        const sender = EndPoint.new(unmapIP(addr.*), port);

        logger.debug("received some data via udp: {} bytes from {}", .{ limited_len, sender });

        data.receive_iop = null;
        ashet.io.finalizeWithResult(iop, .{
            .bytes_received = limited_len,
            .sender = sender,
        });
    }

    pub fn destroySocket(sock: Socket) void {
        const pcb = unmap(sock) catch return;
        const index = @intFromEnum(sock);
        c.udp_remove(pcb);
        sockets[index] = undefined;
        socket_meta[index] = undefined;
        pool.free(index);
    }

    pub fn bind(data: *abi_udp.Bind) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);
        lwipTry(c.udp_bind(pcb, &mapIP(data.inputs.bind_point.ip), data.inputs.bind_point.port)) catch |err| return ashet.io.finalizeWithError(data, err);
        ashet.io.finalizeWithResult(data, .{});
    }

    pub fn connect(data: *abi_udp.Connect) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);
        lwipTry(c.udp_connect(pcb, &mapIP(data.inputs.target.ip), data.inputs.target.port)) catch |err| return ashet.io.finalizeWithError(data, err);
        ashet.io.finalizeWithResult(data, .{});
    }

    pub fn disconnect(data: *abi_udp.Disconnect) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);
        c.udp_disconnect(pcb);
        ashet.io.finalizeWithResult(data, .{});
    }

    pub fn send(data: *abi_udp.Send) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);

        const stripped_len = std.math.cast(u16, data.inputs.data_len) orelse return ashet.io.finalizeWithError(data, error.OutOfMemory);

        const pbuf = c.pbuf_alloc(c.PBUF_TRANSPORT, stripped_len, c.PBUF_POOL) orelse return ashet.io.finalizeWithError(data, error.OutOfMemory);
        defer _ = c.pbuf_free(pbuf);

        appendToPBUF(pbuf, data.inputs.data_ptr[0..stripped_len]) catch |err| return ashet.io.finalizeWithError(data, err);

        lwipTry(c.udp_send(pcb, pbuf)) catch |err| return ashet.io.finalizeWithError(data, err);

        ashet.io.finalizeWithResult(data, .{ .bytes_sent = stripped_len });
    }

    pub fn sendTo(data: *abi_udp.SendTo) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);

        const stripped_len = std.math.cast(u16, data.inputs.data_len) orelse return ashet.io.finalizeWithError(data, error.OutOfMemory);

        const pbuf = c.pbuf_alloc(c.PBUF_TRANSPORT, stripped_len, c.PBUF_POOL) orelse return ashet.io.finalizeWithError(data, error.OutOfMemory);
        defer _ = c.pbuf_free(pbuf);

        appendToPBUF(pbuf, data.inputs.data_ptr[0..stripped_len]) catch |err| return ashet.io.finalizeWithError(data, err);

        lwipTry(c.udp_sendto(pcb, pbuf, &mapIP(data.inputs.receiver.ip), data.inputs.receiver.port)) catch |err| return ashet.io.finalizeWithError(data, err);

        ashet.io.finalizeWithResult(data, .{ .bytes_sent = stripped_len });
    }

    pub fn receiveFrom(data: *abi_udp.ReceiveFrom) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);
        const context = &socket_meta[@intFromEnum(data.inputs.socket)];

        _ = pcb;
        if (context.receive_iop != null) {
            return ashet.io.finalizeWithError(data, error.InProgress);
        }
        context.receive_iop = data;
    }
};

pub const tcp = struct {
    const max_sockets = @as(usize, @intCast(c.MEMP_NUM_TCP_PCB));

    const Op = union(enum) {
        connect: *ashet.@"async".AsyncCall,
        receive: ReceiveOp,
        send: SendOp,

        pub fn event(op: *Op) *ashet.abi.IOP {
            return switch (op.*) {
                .connect => |dat| &dat.iop,
                .receive => |*dat| &dat.event.iop,
                .send => |*dat| &dat.event.iop,
            };
        }

        pub fn finalize(op: *Op, err: anyerror!void) void {
            switch (op.*) {
                .connect => |ev| ev.finalize_with_result(ashet.abi.tcp.Connect, err),
                .receive => |dat| dat.event.finalize_with_result(ashet.abi.tcp.Receive, err),
                .send => |*dat| dat.event.finalize_with_result(ashet.abi.tcp.Send, err),
            }
            ashet.io.finalize(op.event());
        }
    };

    const SendOp = struct {
        event: *ashet.@"async".AsyncCall,
        total_sent: usize = 0, // total bytes transferred for `event`.
        chunk_size: usize = 0, // passsed bytes for the current chunk (invocation of op.total_sent
        chunk_sent: usize = 0, // transferred bytes for the current chunk (invocation of op.total_sent)
    };

    const ReceiveOp = struct {
        event: *ashet.@"async".AsyncCall,
        write_offset: usize = 0,
    };

    pub const Socket = struct {
        system_resource: ashet.resources.SystemResource = .{ .type = .tcp_socket },

        pcb: *c.tcp_pcb,

        connected: bool = false, // true when the connection has been established
        closed: bool = false, // true when the connection has been closed
        op: ?Op = null,

        /// offset in the currently queued pbuf provided in the tcpRecvCallback.
        /// When all bytes in that pbuf are received, we can free it and accept more data.
        recv_offset: u16 = 0,

        pub fn create() error{SystemResources}!*Socket {
            const socket = ashet.memory.type_pool(Socket).alloc() catch return error.SystemResources;
            errdefer ashet.memory.type_pool(Socket).free(socket);

            const pcb = c.tcp_new() orelse return error.SystemResources;
            errdefer comptime unreachable;

            c.tcp_arg(pcb, socket);

            c.tcp_err(pcb, tcpErrCallback);
            c.tcp_recv(pcb, tcpRecvCallback);
            c.tcp_sent(pcb, tcpSentCallback);
            // c.tcp_accept(pcb, tcp_accept_fn);

            return socket;
        }

        pub fn destroy(sock: *Socket) void {
            if (c.tcp_close(sock.pcb) != c.ERR_OK) {
                c.tcp_abort(sock.pcb);
            }

            // while (socket_meta[index].receive_queue.pull()) |packet| {
            //     _ = c.pbuf_free(packet.data);
            // }

            ashet.memory.type_pool(Socket).free(sock);
        }

        fn from_callback(arg: ?*anyopaque) *Socket {
            return @ptrCast(@alignCast(arg.?));
        }
    };

    fn resolve_socket(call: *ashet.@"async".AsyncCall, dir: ashet.abi.TcpSocket) error{InvalidHandle}!*Socket {
        const proc = call.get_process();
        return ashet.resources.resolve(Socket, proc, dir.as_resource()) catch |err| {
            logger.warn("process {} used invalid socket handle {}: {s}", .{ proc, dir, @errorName(err) });
            return error.InvalidHandle;
        };
    }

    fn tcpErrCallback(arg: ?*anyopaque, err: c.err_t) callconv(.C) void {
        const sock = Socket.from_callback(arg);

        logger.err("tcp: err(arg={*}, err={!})", .{ arg, lwipTry(err) });

        if (sock.op) |*op| {
            op.finalize(lwipTry(err));
        }
    }

    pub fn bind(call: *ashet.@"async".AsyncCall, inputs: abi_tcp.Bind.Inputs) void {
        const socket = resolve_socket(call, inputs.socket) catch |err| {
            return call.finalize(abi_tcp.Bind, err);
        };

        if (lwip.tcp.bind(socket.pcb, &mapIP(inputs.bind_point.ip), inputs.bind_point.port)) {
            return call.finalize(abi_tcp.Bind, .{ .bind_point = EndPoint{
                .ip = unmapIP(socket.pcb.local_ip),
                .port = socket.pcb.local_port,
            } });
        } else |err| {
            return call.finalize(abi_tcp.Bind, err);
        }
    }

    pub fn connect(call: *ashet.@"async".AsyncCall, inputs: abi_tcp.Connect.Inputs) void {
        const socket = resolve_socket(call, inputs.socket) catch |err| {
            return call.finalize(abi_tcp.Bind, err);
        };
        if (socket.op != null) {
            return call.finalize(abi_tcp.Connect, error.InProgress);
        }

        socket.op = .{ .connect = call };

        if (lwip.tcp.connect(socket.pcb, &mapIP(inputs.target.ip), inputs.target.port, tcpConnectedCallback)) {
            // async call will be resolved by the callback
        } else |err| {
            socket.op = null;
            return call.finalize(abi_tcp.Connect, err);
        }
    }

    fn tcpConnectedCallback(arg: ?*anyopaque, pcb_c: [*c]c.tcp_pcb, err: c.err_t) callconv(.C) c.err_t {
        const pcb: *c.tcp_pcb = pcb_c;
        const socket = Socket.from_callback(arg);
        const event = socket.op.?.connect;

        // err: An unused error code, always ERR_OK currently ;-)
        std.debug.assert(err == c.ERR_OK);

        logger.debug("tcp: connected(arg={}, pcb={*}, err={!})", .{ socket, pcb, lwipTry(err) });

        socket.connected = true;
        socket.op = null;
        event.finalize(abi_tcp.Connect, .{});

        return c.ERR_OK;
    }

    pub fn send(call: *ashet.@"async".AsyncCall, inputs: abi_tcp.Send.Inputs) void {
        const socket = resolve_socket(call, inputs.socket) catch |err| {
            return call.finalize(abi_tcp.Bind, err);
        };
        if (socket.op != null) {
            return call.finalize(abi_tcp.Send, error.InProgress);
        }

        if (!socket.connected) {
            return call.finalize(abi_tcp.Send, error.NotConnected);
        }
        if (socket.closed) {
            return call.finalize(abi_tcp.Send, .{
                .bytes_sent = 0,
            });
        }

        socket.op = .{ .send = .{ .event = call } };
        const op = &socket.op.?.send;

        transferNextChunk(socket.pcb, socket, op);
    }

    fn transferNextChunk(pcb: *c.tcp_pcb, socket: *Socket, op: *SendOp) void {
        const call = op.event;
        const iop = call.arc.cast(abi_tcp.Send);

        if (op.total_sent == iop.inputs.data_len) {
            socket.op = null;
            return call.finalize(abi_tcp.Send, .{ .bytes_sent = op.total_sent });
        }

        const rest_len = iop.inputs.data_len - op.total_sent;
        const rest_limited = @min(c.tcp_sndbuf(pcb), limitLength(rest_len));

        const last = true; // (op.total_sent + rest_limited == event.data_len);

        if (lwip.tcp.write(pcb, iop.inputs.data_ptr + op.total_sent, rest_limited, if (!last) c.TCP_WRITE_FLAG_MORE else 0)) {
            op.chunk_sent = 0;
            op.chunk_size = rest_limited;
            return;
        } else |err| {
            if (err == error.OutOfMemory) {
                @panic("not handled yet: reschedule the transfer at a later point again");
            }

            logger.err("failed to send: {}", .{err});

            socket.op = null;
            return call.finalize(abi_tcp.Send, err);
        }
    }

    fn tcpSentCallback(arg: ?*anyopaque, pcb_c: [*c]c.tcp_pcb, sent: u16) callconv(.C) c.err_t {
        const pcb: *c.tcp_pcb = pcb_c;
        const socket = Socket.from_callback(arg);

        const op = &socket.op.?.send;
        const iop = op.event.arc.cast(abi_tcp.Send);

        op.total_sent += sent;
        op.chunk_sent += sent;
        std.debug.assert(op.total_sent <= iop.inputs.data_len);

        if (op.chunk_sent == op.chunk_size) {
            logger.debug("tcp: full transfer(sent {} bytes, now {} bytes. sending next chunk)", .{ sent, op.chunk_size });
            transferNextChunk(pcb, socket, op);
        } else {
            // Just happily idle until our current chunk is fully transferred
            logger.debug("tcp: partial transfer(sent {} bytes, now {} of {} bytes)", .{ sent, op.chunk_sent, op.chunk_size });
        }

        return c.ERR_OK;
    }

    pub fn receive(call: *ashet.@"async".AsyncCall, inputs: abi_tcp.Receive.Inputs) void {
        const socket = resolve_socket(call, inputs.socket) catch |err| {
            return call.finalize(abi_tcp.Bind, err);
        };
        if (socket.op != null) {
            return call.finalize(abi_tcp.Receive, error.InProgress);
        }

        if (!socket.connected) {
            return call.finalize(abi_tcp.Receive, error.NotConnected);
        }
        if (socket.closed) {
            return call.finalize(abi_tcp.Receive, .{ .bytes_received = 0 });
        }

        // for receiption, we just set up the buffer and wait until it's completed
        socket.op = .{ .receive = .{ .event = call } };
    }

    // Sets the callback function that will be called when new data arrives. The callback function will be passed a NULL pbuf to indicate that the remote host has closed the connection.
    // If the callback function returns ERR_OK or ERR_ABRT it must have freed the pbuf, otherwise it must not have freed it.
    fn tcpRecvCallback(arg: ?*anyopaque, pcb_c: [*c]c.tcp_pcb, pbuf_c: [*c]c.pbuf, err: c.err_t) callconv(.C) c.err_t {
        const pcb: *c.tcp_pcb = pcb_c;
        const socket = Socket.from_callback(arg);

        if (err != c.ERR_OK) {
            logger.debug("tcp: recv(arg={}, tot_len=<nil>, err={!})", .{ socket, lwipTry(err) });
            return c.ERR_OK;
        }

        if (pbuf_c == null) {
            socket.closed = true;
            logger.debug("tcp: recv(arg={},  tot_len=<nil>, err=end of stream)", .{socket});

            if (socket.op) |*op| {
                op.finalize({});
                socket.op = null;
            }

            return c.ERR_OK;
        }

        if (socket.op == null) {
            return c.ERR_WOULDBLOCK; // we can't receive anything right now
        }

        const op: *ReceiveOp = switch (socket.op.?) {
            .receive => |*op| op,
            else => return c.ERR_WOULDBLOCK, // we can't receive anything right now
        };
        const call = op.event;
        const iop = op.event.arc.cast(abi_tcp.Receive);

        const pbuf: *c.pbuf = pbuf_c;

        std.debug.assert(pbuf.tot_len > socket.recv_offset);
        const available_src = pbuf.tot_len - socket.recv_offset;
        const available_dst = iop.inputs.buffer_len;

        const copy_len = @min(available_dst, available_src);

        const copied_len = c.pbuf_copy_partial(pbuf, iop.inputs.buffer_ptr, copy_len, socket.recv_offset);

        if (copied_len == 0) {
            logger.err("failed to copy data from recv callback into async receive event", .{});
        }

        socket.recv_offset += copied_len;
        op.write_offset += copied_len;

        c.tcp_recved(pcb, copied_len);

        if (op.write_offset == iop.inputs.buffer_len or !iop.inputs.read_all) {
            // op completed
            call.finalize(abi_tcp.Receive, .{
                .bytes_received = op.write_offset,
            });
            socket.op = null;
            return;
        }

        if (socket.recv_offset == pbuf.tot_len) {
            // we consumed all of this buffer, notify stack that we're done now.
            socket.recv_offset = 0;
            _ = c.pbuf_free(pbuf);
            return c.ERR_OK;
        } else {
            return c.ERR_WOULDBLOCK;
        }
    }
};
