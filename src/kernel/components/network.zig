const std = @import("std");
const abi = ashet.abi;
const ashet = @import("../main.zig");
const astd = @import("ashet-std");
const logger = std.log.scoped(.network);

const c = @cImport({
    @cInclude("lwip/init.h");
    @cInclude("lwip/tcpip.h");
    @cInclude("lwip/netif.h");
    @cInclude("lwip/dhcp.h");
    @cInclude("lwip/tcp.h");
    @cInclude("lwip/udp.h");
    @cInclude("lwip/etharp.h");
    @cInclude("lwip/ethip6.h");
    @cInclude("lwip/timeouts.h");
});

pub const Interface = enum {
    ethernet,
    ieee802_11,

    pub fn prefix(i: Interface) u8 {
        return switch (i) {
            .ethernet => 'E',
            .ieee802_11 => 'W',
        };
    }
};

pub const MAC = struct {
    tuple: [6]u8,
    pub fn init(v: [6]u8) MAC {
        return MAC{ .tuple = v };
    }

    pub fn format(mac: MAC, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;

        try writer.print("{X:0>2}:{X:0>2}:{X:0>2}:{X:0>2}:{X:0>2}:{X:0>2}", .{
            mac.tuple[0],
            mac.tuple[1],
            mac.tuple[2],
            mac.tuple[3],
            mac.tuple[4],
            mac.tuple[5],
        });
    }
};

pub fn appendToPBUF(pbuf: *c.pbuf, data: []const u8) !void {
    const len = std.math.cast(u16, data.len) orelse return error.OutOfMemory;
    try lwipTry(c.pbuf_take(pbuf, data.ptr, len));
}

pub const IncomingPacket = struct {
    pbuf: *c.pbuf,

    pub fn append(packet: IncomingPacket, data: []const u8) !void {
        try appendToPBUF(packet.pbuf, data);
    }
};

pub const NetworkInterface = struct {
    pub const VTable = struct {
        /// Returns `true` if the link is up and a cable is connected.
        linkIsUpFn: *const fn (*ashet.drivers.Driver) bool,

        /// Allocates a network packet from the driver that can be
        /// sent with the `send` function.
        /// Values returned by `allocPacket` are guaranteed to be dispatched
        /// to `send`.
        allocOutgoingPacketFn: *const fn (*ashet.drivers.Driver, size: usize) ?[]u8,

        /// Sends a packet previously allocated with `allocPacket` to
        /// the interface. The function is guaranteed to be called only
        /// with values generated by `allocPacket`.
        sendFn: *const fn (*ashet.drivers.Driver, buffer: []u8) bool,

        /// Polls the NetworkInterface for new incoming packages.
        /// Is called periodically to ensure network liveness.
        pollFn: *const fn (*ashet.drivers.Driver) void,
    };

    interface: Interface,
    address: MAC,
    mtu: u16,

    vtable: *const VTable,

    dhcp: c.dhcp = undefined,
    netif: c.netif = undefined,

    pub fn allocIncomingPacket(nic: *NetworkInterface, size: usize) !IncomingPacket {
        _ = nic;

        const len = std.math.cast(u16, size) orelse return error.PacketTooBig;

        const pbuf: *c.pbuf = c.pbuf_alloc(c.PBUF_RAW, len, c.PBUF_POOL) orelse return error.OutOfMemory;

        return IncomingPacket{ .pbuf = pbuf };
    }

    pub fn freeIncomingPacket(nic: *NetworkInterface, packet: IncomingPacket) void {
        _ = nic;
        _ = c.pbuf_free(packet.pbuf); // return value is irrelevant for us
    }

    pub fn receive(nic: *NetworkInterface, packet: IncomingPacket) void {
        if (nic.netif.input.?(packet.pbuf, &nic.netif) != c.ERR_OK) {
            _ = c.pbuf_free(packet.pbuf); // return value is irrelevant for us
        }
    }

    pub fn getName(nic: *const NetworkInterface) []const u8 {
        return &nic.netif.name;
    }

    fn linkIsUp(nic: *NetworkInterface) bool {
        return nic.vtable.linkIsUpFn(ashet.drivers.resolveDriver(.network, nic));
    }
    fn allocOutgoingPacket(nic: *NetworkInterface, size: usize) ?[]u8 {
        return nic.vtable.allocOutgoingPacketFn(ashet.drivers.resolveDriver(.network, nic), size);
    }
    fn send(nic: *NetworkInterface, buffer: []u8) bool {
        return nic.vtable.sendFn(ashet.drivers.resolveDriver(.network, nic), buffer);
    }
    fn poll(nic: *NetworkInterface) void {
        return nic.vtable.pollFn(ashet.drivers.resolveDriver(.network, nic));
    }
};

const IPFormatter = struct {
    addr: c.ip_addr_t,

    pub fn new(addr: c.ip_addr_t) IPFormatter {
        return IPFormatter{ .addr = addr };
    }

    pub fn format(addr: IPFormatter, comptime fmt: []const u8, opt: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = opt;
        try writer.writeAll(std.mem.sliceTo(c.ip4addr_ntoa(@as(*const c.ip4_addr_t, @ptrCast(&addr.addr))), 0));
    }
};

fn netif_status_callback(netif_c: [*c]c.netif) callconv(.C) void {
    const netif: *c.netif = netif_c;

    logger.info("netif status changed ip to {}", .{IPFormatter.new(netif.ip_addr)});
}

fn netif_init(netif_c: [*c]c.netif) callconv(.C) c.err_t {
    const netif: *c.netif = netif_c;
    const nic = @fieldParentPtr(NetworkInterface, "netif", netif);

    netif.linkoutput = netif_output;
    netif.output = c.etharp_output;
    netif.output_ip6 = c.ethip6_output;
    netif.mtu = nic.mtu; // c.ETHERNET_MTU;
    netif.flags = c.NETIF_FLAG_BROADCAST | c.NETIF_FLAG_ETHARP | c.NETIF_FLAG_ETHERNET | c.NETIF_FLAG_IGMP | c.NETIF_FLAG_MLD6;
    // c.MIB2_INIT_NETIF(netif, c.snmp_ifType_ethernet_csmacd, 100000000);
    std.mem.copyForwards(u8, &netif.hwaddr, &nic.address.tuple);
    netif.hwaddr_len = c.ETH_HWADDR_LEN;
    return c.ERR_OK;
}

fn netif_output(netif_c: [*c]c.netif, pbuf_c: [*c]c.pbuf) callconv(.C) c.err_t {
    const netif: *c.netif = netif_c;
    const pbuf: *c.pbuf = pbuf_c;
    const nic = @fieldParentPtr(NetworkInterface, "netif", netif);

    // c.LINK_STATS_INC(lwip_stats.link.xmit);
    // Update SNMP stats (only if you use SNMP)
    // c.MIB2_STATS_NETIF_ADD(netif, ifoutoctets, pbuf.tot_len);
    // const unicast = ((pbuf.payload[0] & 0x01) == 0);
    // if (unicast) {
    //     c.MIB2_STATS_NETIF_INC(netif, ifoutucastpkts);
    // } else {
    //     c.MIB2_STATS_NETIF_INC(netif, ifoutnucastpkts);
    // }

    // TODO: lock_interrupts();

    logger.debug("sending {} bytes via {s}...", .{ pbuf.tot_len, netif.name });

    if (nic.allocOutgoingPacket(pbuf.tot_len)) |packet| {
        // TODO: Handle length here
        var off: usize = 0;
        while (off < pbuf.tot_len) {
            const cnt = c.pbuf_copy_partial(pbuf, packet.ptr + off, @as(u15, @intCast(pbuf.tot_len - off)), @as(u15, @intCast(off)));
            if (cnt == 0) {
                logger.err("failed to copy network packet", .{});
                return c.ERR_BUF;
            }
            off += cnt;
        }
        if (!nic.send(packet)) {
            logger.err("failed to send network packet!", .{});
        }
    } else {
        logger.err("failed to allocate network packet!", .{});
    }

    // TODO: unlock_interrupts();
    return c.ERR_OK;
}

pub fn start() !void {
    c.lwip_init();

    var index: usize = 0;
    var nics = ashet.drivers.enumerate(.network);
    while (nics.next()) |nic| : (index += 1) {
        logger.info("initializing NetworkInterface '{c}{d}' (MAC={})...", .{ nic.interface.prefix(), index, nic.address });

        const netif = &nic.netif;

        _ = c.netif_add(
            netif,
            @as(*c.ip4_addr_t, @ptrCast(c.IP4_ADDR_ANY)), // ipaddr
            @as(*c.ip4_addr_t, @ptrCast(c.IP4_ADDR_ANY)), // netmask
            @as(*c.ip4_addr_t, @ptrCast(c.IP4_ADDR_ANY)), // gw
            null,
            netif_init,
            c.netif_input,
        ) orelse return error.OutOfMemory;

        _ = try std.fmt.bufPrint(&netif.name, "{c}{d}", .{ nic.interface.prefix(), index });

        c.netif_create_ip6_linklocal_address(netif, 1);
        netif.ip6_autoconfig_enabled = 1;
        c.netif_set_status_callback(netif, netif_status_callback);
        c.netif_set_default(netif);

        c.dhcp_set_struct(netif, &nic.dhcp);

        c.netif_set_up(netif);

        try lwipTry(c.dhcp_start(netif));

        c.netif_set_link_up(netif);
    }

    if (index > 0) {
        logger.info("Network adapters found, starting network task...", .{});

        // we found a network adapter, start the backgruond thread
        const network_thread = try ashet.scheduler.Thread.spawn(networkThread, null, .{});
        errdefer network_thread.kill();

        try network_thread.setName("ashet.network");
        try network_thread.start();
        network_thread.detach();
    }
}

pub fn dumpStats() void {
    var nics = ashet.drivers.enumerate(.network);
    while (nics.next()) |nic| {
        logger.info("nic {s}: up={} link={} ip={} netmask={} gateway={} dhcp={}", .{
            nic.netif.name,
            (nic.netif.flags & c.NETIF_FLAG_UP) != 0,
            (nic.netif.flags & c.NETIF_FLAG_LINK_UP) != 0,
            IPFormatter.new(nic.netif.ip_addr),
            IPFormatter.new(nic.netif.netmask),
            IPFormatter.new(nic.netif.gw),
            c.dhcp_supplied_address(&nic.netif) != 0,
        });
    }
}

fn networkThread(_: ?*anyopaque) callconv(.C) u32 {
    while (true) {
        var nics = ashet.drivers.enumerate(.network);
        while (nics.next()) |nic| {
            nic.poll();
        }
        c.sys_check_timeouts();
        ashet.scheduler.yield();
    }
}

// Returns the current time in milliseconds, may be the same as sys_jiffies or at least based on it.
// Don't care for wraparound, this is only used for time diffs. Not implementing this function means
// you cannot use some modules (e.g. TCP timestamps, internal timeouts for NO_SYS==1).
export fn sys_now() u32 {
    return @as(u32, @truncate(@as(u64, @bitCast(ashet.time.milliTimestamp()))));
}

const LwipError = error{
    /// Out of memory error.
    OutOfMemory,
    /// Buffer error.
    BufferError,
    /// Timeout.
    Timeout,
    /// Routing problem.
    Routing,
    /// Operation in progress
    InProgress,
    /// Illegal value.
    IllegalValue,
    /// Operation would block.
    WouldBlock,
    /// Address in use.
    AddressInUse,
    /// Already connecting.
    AlreadyConnecting,
    /// Conn already established.
    AlreadyConnected,
    /// Not connected.
    NotConnected,
    /// Low-level netif error
    LowlevelInterfaceError,
    /// Connection aborted.
    ConnectionAborted,
    /// Connection reset.
    ConnectionReset,
    /// Connection closed.
    ConnectionClosed,
    /// Illegal argument.
    IllegalArgument,

    /// Unexpected error code
    Unexpected,
};

fn lwipErr(err: c.err_t) LwipError {
    if (lwipTry(err)) |_|
        unreachable
    else |e|
        return e;
}

fn lwipTry(err: c.err_t) LwipError!void {
    return switch (err) {
        c.ERR_OK => {},
        c.ERR_MEM => LwipError.OutOfMemory,
        c.ERR_BUF => LwipError.BufferError,
        c.ERR_TIMEOUT => LwipError.Timeout,
        c.ERR_RTE => LwipError.Routing,
        c.ERR_INPROGRESS => LwipError.InProgress,
        c.ERR_VAL => LwipError.IllegalValue,
        c.ERR_WOULDBLOCK => LwipError.WouldBlock,
        c.ERR_USE => LwipError.AddressInUse,
        c.ERR_ALREADY => LwipError.AlreadyConnecting,
        c.ERR_ISCONN => LwipError.AlreadyConnected,
        c.ERR_CONN => LwipError.NotConnected,
        c.ERR_IF => LwipError.LowlevelInterfaceError,
        c.ERR_ABRT => LwipError.ConnectionAborted,
        c.ERR_RST => LwipError.ConnectionReset,
        c.ERR_CLSD => LwipError.ConnectionClosed,
        c.ERR_ARG => LwipError.IllegalArgument,
        else => LwipError.Unexpected,
    };
}

pub const EndPoint = abi.EndPoint;
pub const IP = abi.IP;

fn mapIP(ip: IP) c.ip_addr_t {
    return switch (ip.type) {
        .ipv4 => c.ip_addr_t{
            .type = c.IPADDR_TYPE_V4,
            .u_addr = .{ .ip4 = .{ .addr = @as(u32, @bitCast(ip.addr.v4.addr)) } },
        },
        .ipv6 => c.ip_addr_t{
            .type = c.IPADDR_TYPE_V6,
            .u_addr = .{ .ip6 = .{ .addr = @as([4]u32, @bitCast(ip.addr.v6.addr)), .zone = ip.addr.v6.zone } },
        },
    };
}

fn unmapIP(addr: c.ip_addr_t) IP {
    return switch (addr.type) {
        c.IPADDR_TYPE_V4 => IP{
            .type = .ipv4,
            .addr = .{ .v4 = .{ .addr = @as([4]u8, @bitCast(addr.u_addr.ip4.addr)) } },
        },
        c.IPADDR_TYPE_V6 => IP{
            .type = .ipv6,
            .addr = .{ .v6 = .{ .addr = @as([16]u8, @bitCast(addr.u_addr.ip6.addr)), .zone = addr.u_addr.ip6.zone } },
        },
        else => unreachable,
    };
}

fn limitLength(val: usize) u16 {
    @setRuntimeSafety(false);
    return @as(u16, @intCast(std.math.min(val, std.math.maxInt(u16))));
}

pub const udp = struct {
    const max_sockets = @as(usize, @intCast(c.MEMP_NUM_UDP_PCB));
    const Socket = abi.UdpSocket;

    const Data = struct {
        receive_iop: ?*abi.udp.ReceiveFrom = null,
    };

    var pool: astd.IndexPool(u32, max_sockets) = .{};
    var sockets: [max_sockets]*c.udp_pcb = undefined;
    var socket_meta: [max_sockets]Data = undefined;

    fn unmap(sock: Socket) error{InvalidHandle}!*c.udp_pcb {
        if (sock == .invalid)
            return error.InvalidHandle;
        const index = @intFromEnum(sock);
        if (index >= max_sockets)
            return error.InvalidHandle;
        if (!pool.alive(index))
            return error.InvalidHandle;
        return sockets[index];
    }

    pub fn createSocket() !Socket {
        const index = pool.alloc() orelse return error.SystemResources;
        errdefer pool.free(index);

        const pcb = c.udp_new() orelse return error.SystemResources;
        sockets[index] = pcb;

        socket_meta[index] = Data{};

        c.udp_recv(pcb, handleIncomingPacket, &socket_meta[index]);

        return @as(Socket, @enumFromInt(index));
    }

    fn handleIncomingPacket(arg: ?*anyopaque, pcb_c: [*c]c.udp_pcb, pbuf_c: [*c]c.pbuf, addr_c: [*c]const c.ip_addr_t, port: u16) callconv(.C) void {
        const data: *Data = @ptrCast(@alignCast(arg));
        const pcb: *c.udp_pcb = pcb_c;
        var pbuf: *c.pbuf = pbuf_c;
        const addr: *const c.ip_addr_t = addr_c;

        _ = pcb;

        const iop = data.receive_iop orelse {
            logger.err("failed to queue received pbuf. dropping packet of {} bytes.", .{pbuf.tot_len});
            _ = c.pbuf_free(pbuf);
            return;
        };

        const limited_len = @as(u16, @truncate(std.math.min(pbuf.tot_len, iop.inputs.buffer_len)));

        const copied = c.pbuf_copy_partial(pbuf, iop.inputs.buffer_ptr, limited_len, 0);
        std.debug.assert(limited_len == copied);
        _ = c.pbuf_free(pbuf);

        const sender = EndPoint.new(unmapIP(addr.*), port);

        logger.debug("received some data via udp: {} bytes from {}", .{ limited_len, sender });

        data.receive_iop = null;
        ashet.io.finalizeWithResult(iop, .{
            .bytes_received = limited_len,
            .sender = sender,
        });
    }

    pub fn destroySocket(sock: Socket) void {
        const pcb = unmap(sock) catch return;
        const index = @intFromEnum(sock);
        c.udp_remove(pcb);
        sockets[index] = undefined;
        socket_meta[index] = undefined;
        pool.free(index);
    }

    pub fn bind(data: *abi.udp.Bind) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);
        lwipTry(c.udp_bind(pcb, &mapIP(data.inputs.bind_point.ip), data.inputs.bind_point.port)) catch |err| return ashet.io.finalizeWithError(data, err);
        ashet.io.finalizeWithResult(data, .{});
    }

    pub fn connect(data: *abi.udp.Connect) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);
        lwipTry(c.udp_connect(pcb, &mapIP(data.inputs.target.ip), data.inputs.target.port)) catch |err| return ashet.io.finalizeWithError(data, err);
        ashet.io.finalizeWithResult(data, .{});
    }

    pub fn disconnect(data: *abi.udp.Disconnect) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);
        c.udp_disconnect(pcb);
        ashet.io.finalizeWithResult(data, .{});
    }

    pub fn send(data: *abi.udp.Send) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);

        const stripped_len = std.math.cast(u16, data.inputs.data_len) orelse return ashet.io.finalizeWithError(data, error.OutOfMemory);

        const pbuf = c.pbuf_alloc(c.PBUF_TRANSPORT, stripped_len, c.PBUF_POOL) orelse return ashet.io.finalizeWithError(data, error.OutOfMemory);
        defer _ = c.pbuf_free(pbuf);

        appendToPBUF(pbuf, data.inputs.data_ptr[0..stripped_len]) catch |err| return ashet.io.finalizeWithError(data, err);

        lwipTry(c.udp_send(pcb, pbuf)) catch |err| return ashet.io.finalizeWithError(data, err);

        ashet.io.finalizeWithResult(data, .{ .bytes_sent = stripped_len });
    }

    pub fn sendTo(data: *abi.udp.SendTo) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);

        const stripped_len = std.math.cast(u16, data.inputs.data_len) orelse return ashet.io.finalizeWithError(data, error.OutOfMemory);

        const pbuf = c.pbuf_alloc(c.PBUF_TRANSPORT, stripped_len, c.PBUF_POOL) orelse return ashet.io.finalizeWithError(data, error.OutOfMemory);
        defer _ = c.pbuf_free(pbuf);

        appendToPBUF(pbuf, data.inputs.data_ptr[0..stripped_len]) catch |err| return ashet.io.finalizeWithError(data, err);

        lwipTry(c.udp_sendto(pcb, pbuf, &mapIP(data.inputs.receiver.ip), data.inputs.receiver.port)) catch |err| return ashet.io.finalizeWithError(data, err);

        ashet.io.finalizeWithResult(data, .{ .bytes_sent = stripped_len });
    }

    pub fn receiveFrom(data: *abi.udp.ReceiveFrom) void {
        const pcb = unmap(data.inputs.socket) catch |err| return ashet.io.finalizeWithError(data, err);
        const context = &socket_meta[@intFromEnum(data.inputs.socket)];

        _ = pcb;
        if (context.receive_iop != null) {
            return ashet.io.finalizeWithError(data, error.InProgress);
        }
        context.receive_iop = data;
    }
};

fn mapErrSet(comptime T: type, err_or_ok: anyerror!void) T.Enum {
    return if (err_or_ok) |_|
        .ok
    else |err|
        T.map(astd.mapToUnexpected(T.Error, err));
}

pub const tcp = struct {
    const max_sockets = @as(usize, @intCast(c.MEMP_NUM_TCP_PCB));
    const Socket = abi.TcpSocket;

    const Op = union(enum) {
        connect: *abi.tcp.Connect,
        receive: ReceiveOp,
        send: SendOp,

        pub fn event(op: *Op) *ashet.abi.IOP {
            return switch (op.*) {
                .connect => |dat| &dat.iop,
                .receive => |*dat| &dat.event.iop,
                .send => |*dat| &dat.event.iop,
            };
        }

        pub fn finalize(op: *Op, err: anyerror!void) void {
            switch (op.*) {
                .connect => |ev| ev.@"error" = mapErrSet(ashet.abi.tcp.ConnectError, err),
                .receive => |dat| dat.event.@"error" = mapErrSet(ashet.abi.tcp.ReceiveError, err),
                .send => |*dat| dat.event.@"error" = mapErrSet(ashet.abi.tcp.SendError, err),
            }
            ashet.io.finalize(op.event());
        }
    };

    const SendOp = struct {
        event: *abi.tcp.Send,
        total_sent: usize = 0, // total bytes transferred for `event`.
        chunk_size: usize = 0, // passsed bytes for the current chunk (invocation of op.total_sent
        chunk_sent: usize = 0, // transferred bytes for the current chunk (invocation of op.total_sent)
    };

    const ReceiveOp = struct {
        event: *abi.tcp.Receive,
        write_offset: usize = 0,
    };

    const Data = struct {
        connected: bool = false, // true when the connection has been established
        closed: bool = false, // true when the connection has been closed
        op: ?Op = null,

        /// offset in the currently queued pbuf provided in the tcpRecvCallback.
        /// When all bytes in that pbuf are received, we can free it and accept more data.
        recv_offset: u16 = 0,

        pub fn fromArg(arg: ?*anyopaque) *Data {
            return @ptrCast(@alignCast(arg.?));
        }
    };

    var pool: astd.IndexPool(u32, max_sockets) = .{};
    var sockets: [max_sockets]*c.tcp_pcb = undefined;
    var socket_meta: [max_sockets]Data = undefined;

    fn unmap(sock: Socket) error{InvalidHandle}!*c.tcp_pcb {
        if (sock == .invalid)
            return error.InvalidHandle;
        const index = @intFromEnum(sock);
        if (index >= max_sockets)
            return error.InvalidHandle;
        if (!pool.alive(index))
            return error.InvalidHandle;
        return sockets[index];
    }

    pub fn createSocket() !Socket {
        const index = pool.alloc() orelse return error.SystemResources;
        errdefer pool.free(index);

        const pcb = c.tcp_new() orelse return error.SystemResources;
        sockets[index] = pcb;

        socket_meta[index] = Data{};

        c.tcp_arg(pcb, &socket_meta[index]);

        c.tcp_err(pcb, tcpErrCallback);
        c.tcp_recv(pcb, tcpRecvCallback);
        c.tcp_sent(pcb, tcpSentCallback);
        // c.tcp_accept(pcb, tcp_accept_fn);

        return @as(Socket, @enumFromInt(index));
    }

    pub fn destroySocket(sock: Socket) void {
        const pcb = unmap(sock) catch return;
        const index = @intFromEnum(sock);

        if (c.tcp_close(pcb) != c.ERR_OK) {
            c.tcp_abort(pcb);
        }

        // while (socket_meta[index].receive_queue.pull()) |packet| {
        //     _ = c.pbuf_free(packet.data);
        // }
        sockets[index] = undefined;
        socket_meta[index] = undefined;
        pool.free(index);
    }

    fn tcpErrCallback(arg: ?*anyopaque, err: c.err_t) callconv(.C) void {
        const state = Data.fromArg(arg);

        logger.err("tcp: err(arg={*}, err={!})", .{ arg, lwipTry(err) });

        if (state.op) |*op| {
            op.finalize(lwipTry(err));
        }
    }

    pub fn bind(ev: *abi.tcp.Bind) void {
        const pcb = unmap(ev.inputs.socket) catch |err| {
            ev.@"error" = abi.tcp.BindError.map(err);
            ashet.io.finalize(&ev.iop);
            return;
        };
        ev.@"error" = mapErrSet(
            abi.tcp.BindError,
            lwipTry(c.tcp_bind(pcb, &mapIP(ev.inputs.bind_point.ip), ev.inputs.bind_point.port)),
        );
        ev.outputs.bind_point = EndPoint{
            .ip = unmapIP(pcb.local_ip),
            .port = pcb.local_port,
        };
        ashet.io.finalize(&ev.iop);
    }

    pub fn connect(ev: *abi.tcp.Connect) void {
        const pcb = unmap(ev.inputs.socket) catch |err| {
            ev.@"error" = abi.tcp.ConnectError.map(err);
            ashet.io.finalize(&ev.iop);
            return;
        };
        const data = &socket_meta[@intFromEnum(ev.inputs.socket)];
        if (data.op != null) {
            ev.@"error" = .InProgress;
            ashet.io.finalize(&ev.iop);
            return;
        }
        data.op = .{ .connect = ev };

        ev.@"error" = mapErrSet(
            abi.tcp.ConnectError,
            lwipTry(c.tcp_connect(pcb, &mapIP(ev.inputs.target.ip), ev.inputs.target.port, tcpConnectedCallback)),
        );
        if (ev.@"error" != .ok) {
            data.op = null;
            ashet.io.finalize(&ev.iop);
        }
    }

    fn tcpConnectedCallback(arg: ?*anyopaque, pcb_c: [*c]c.tcp_pcb, err: c.err_t) callconv(.C) c.err_t {
        const pcb: *c.tcp_pcb = pcb_c;
        const state = Data.fromArg(arg);
        const event = state.op.?.connect;

        // err: An unused error code, always ERR_OK currently ;-)
        std.debug.assert(err == c.ERR_OK);

        logger.debug("tcp: connected(arg={}, pcb={*}, err={!})", .{ state, pcb, lwipTry(err) });

        state.connected = true;
        state.op = null;
        ashet.io.finalize(&event.iop);

        return c.ERR_OK;
    }

    pub fn send(ev: *abi.tcp.Send) void {
        const pcb = unmap(ev.inputs.socket) catch |err| {
            ev.@"error" = abi.tcp.SendError.map(err);
            ashet.io.finalize(&ev.iop);
            return;
        };
        const data = &socket_meta[@intFromEnum(ev.inputs.socket)];
        if (data.op != null) {
            ev.@"error" = .InProgress;
            ashet.io.finalize(&ev.iop);
            return;
        }

        if (!data.connected) {
            ev.@"error" = .NotConnected;
            ashet.io.finalize(&ev.iop);
            return;
        }
        if (data.closed) {
            ev.@"error" = .ok;
            ev.outputs.bytes_sent = 0;
            ashet.io.finalize(&ev.iop);
            return;
        }

        data.op = .{ .send = .{ .event = ev } };
        const op = &data.op.?.send;

        transferNextChunk(pcb, data, op);
    }

    fn transferNextChunk(pcb: *c.tcp_pcb, data: *Data, op: *SendOp) void {
        const event = op.event;

        if (op.total_sent == event.inputs.data_len) {
            event.@"error" = .ok;
            event.outputs.bytes_sent = op.total_sent;
            ashet.io.finalize(&event.iop);
            data.op = null;
            return;
        }

        const rest_len = event.inputs.data_len - op.total_sent;
        const rest_limited = std.math.min(c.tcp_sndbuf(pcb), limitLength(rest_len));

        const last = true; // (op.total_sent + rest_limited == event.data_len);
        event.@"error" = mapErrSet(
            abi.tcp.SendError,
            lwipTry(c.tcp_write(pcb, event.inputs.data_ptr + op.total_sent, rest_limited, if (!last) c.TCP_WRITE_FLAG_MORE else 0)),
        );
        if (event.@"error" == .ok) {
            op.chunk_sent = 0;
            op.chunk_size = rest_limited;
            return;
        }

        if (event.@"error" == .OutOfMemory) {
            @panic("not handled yet: reschedule the transfer at a later point again");
        }

        logger.err("failed to send: {}", .{event.@"error"});
        data.op = null;
        ashet.io.finalize(&event.iop);
    }

    fn tcpSentCallback(arg: ?*anyopaque, pcb_c: [*c]c.tcp_pcb, sent: u16) callconv(.C) c.err_t {
        const pcb: *c.tcp_pcb = pcb_c;
        const state = Data.fromArg(arg);

        const op = &state.op.?.send;

        op.total_sent += sent;
        op.chunk_sent += sent;
        std.debug.assert(op.total_sent <= op.event.inputs.data_len);

        if (op.chunk_sent == op.chunk_size) {
            logger.debug("tcp: full transfer(sent {} bytes, now {} bytes. sending next chunk)", .{ sent, op.chunk_size });
            transferNextChunk(pcb, state, op);
        } else {
            // Just happily idle until our current chunk is fully transferred
            logger.debug("tcp: partial transfer(sent {} bytes, now {} of {} bytes)", .{ sent, op.chunk_sent, op.chunk_size });
        }

        return c.ERR_OK;
    }

    pub fn receive(ev: *abi.tcp.Receive) void {
        const pcb = unmap(ev.inputs.socket) catch |err| {
            ev.@"error" = abi.tcp.ReceiveError.map(err);
            ashet.io.finalize(&ev.iop);
            return;
        };
        const data = &socket_meta[@intFromEnum(ev.inputs.socket)];
        if (data.op != null) {
            ev.@"error" = .InProgress;
            ashet.io.finalize(&ev.iop);
            return;
        }

        if (!data.connected) {
            ev.@"error" = .NotConnected;
            ashet.io.finalize(&ev.iop);
            return;
        }
        if (data.closed) {
            ev.@"error" = .ok;
            ev.outputs.bytes_received = 0;
            ashet.io.finalize(&ev.iop);
            return;
        }

        _ = pcb;

        // for receiption, we just set up the buffer and wait until it's completed
        data.op = .{ .receive = .{ .event = ev } };

        ev.outputs.bytes_received = 0;
        ev.@"error" = .ok;
    }

    // Sets the callback function that will be called when new data arrives. The callback function will be passed a NULL pbuf to indicate that the remote host has closed the connection.
    // If the callback function returns ERR_OK or ERR_ABRT it must have freed the pbuf, otherwise it must not have freed it.
    fn tcpRecvCallback(arg: ?*anyopaque, pcb_c: [*c]c.tcp_pcb, pbuf_c: [*c]c.pbuf, err: c.err_t) callconv(.C) c.err_t {
        const pcb: *c.tcp_pcb = pcb_c;
        const data = Data.fromArg(arg);

        if (err != c.ERR_OK) {
            logger.debug("tcp: recv(arg={}, tot_len=<nil>, err={!})", .{ data, lwipTry(err) });
            return c.ERR_OK;
        }

        if (pbuf_c == null) {
            data.closed = true;
            logger.debug("tcp: recv(arg={},  tot_len=<nil>, err=end of stream)", .{data});

            if (data.op) |*op| {
                op.finalize({});
                data.op = null;
            }

            return c.ERR_OK;
        }

        if (data.op == null) {
            return c.ERR_WOULDBLOCK; // we can't receive anything right now
        }

        const op: *ReceiveOp = switch (data.op.?) {
            .receive => |*op| op,
            else => return c.ERR_WOULDBLOCK, // we can't receive anything right now
        };

        const pbuf: *c.pbuf = pbuf_c;

        std.debug.assert(pbuf.tot_len > data.recv_offset);
        const available_src = pbuf.tot_len - data.recv_offset;
        const available_dst = op.event.inputs.buffer_len;

        const copy_len = std.math.min(available_dst, available_src);

        const copied_len = c.pbuf_copy_partial(pbuf, op.event.inputs.buffer_ptr, copy_len, data.recv_offset);

        if (copied_len == 0) {
            logger.err("failed to copy data from recv callback into async receive event", .{});
        }

        data.recv_offset += copied_len;
        op.write_offset += copied_len;

        c.tcp_recved(pcb, copied_len);

        if (op.write_offset == op.event.inputs.buffer_len or !op.event.inputs.read_all) {
            // op completed

            op.event.outputs.bytes_received = op.write_offset;
            op.event.@"error" = .ok;
            ashet.io.finalize(&op.event.iop);

            data.op = null;
        }

        if (data.recv_offset == pbuf.tot_len) {
            // we consumed all of this buffer, notify stack that we're done now.
            data.recv_offset = 0;
            _ = c.pbuf_free(pbuf);
            return c.ERR_OK;
        } else {
            return c.ERR_WOULDBLOCK;
        }
    }
};
